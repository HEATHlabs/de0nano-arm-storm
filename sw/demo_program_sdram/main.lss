
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a40  00009000  00009000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00004000  00009b00  00009b00  00001a40  2**0
                  ALLOC
  2 .comment      0000001b  00000000  00000000  00001a40  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000040  00000000  00000000  00001a60  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000243  00000000  00000000  00001aa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000007b9  00000000  00000000  00001ce3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000023b  00000000  00000000  0000249c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000002d0  00000000  00000000  000026d7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000024c  00000000  00000000  000029a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002de  00000000  00000000  00002bf4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006d6  00000000  00000000  00002ed2  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00009000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
    9000:	ea000012 	b	9050 <_mainCRTStartup>
        b     und_handler               // undefined - _undf
    9004:	ea000062 	b	9194 <und_handler>
        b     swi_handler               // SWI - _swi
    9008:	ea000055 	b	9164 <swi_handler>
        b     iab_handler               // program abort - _pabt
    900c:	ea000048 	b	9134 <iab_handler>
        b     iab_handler               // data abort - _dabt
    9010:	ea000047 	b	9134 <iab_handler>
        nop                             // reserved
    9014:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
    9018:	e51ffff0 	ldr	pc, [pc, #-4080]	; 8030 <STACK_SIZE+0x4030>
        ldr   pc,[pc,#-0xFF0]           // FIQ - read the VIC
    901c:	e51ffff0 	ldr	pc, [pc, #-4080]	; 8034 <STACK_SIZE+0x4034>

00009020 <_undf>:
    9020:	00009038 	andeq	r9, r0, r8, lsr r0

00009024 <_swi>:
    9024:	0000903c 	andeq	r9, r0, ip, lsr r0

00009028 <_pabt>:
    9028:	00009040 	andeq	r9, r0, r0, asr #32

0000902c <_dabt>:
    902c:	00009044 	andeq	r9, r0, r4, asr #32

00009030 <_irq>:
    9030:	00009048 	andeq	r9, r0, r8, asr #32

00009034 <_fiq>:
    9034:	0000904c 	andeq	r9, r0, ip, asr #32

00009038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
    9038:	eafffffe 	b	9038 <__undf>

0000903c <__swi>:
__swi:  b     .                         // SWI
    903c:	eafffffe 	b	903c <__swi>

00009040 <__pabt>:
__pabt: b     .                         // program abort
    9040:	eafffffe 	b	9040 <__pabt>

00009044 <__dabt>:
__dabt: b     .                         // data abort
    9044:	eafffffe 	b	9044 <__dabt>

00009048 <__irq>:
__irq:  b     .                         // IRQ
    9048:	eafffffe 	b	9048 <__irq>

0000904c <__fiq>:
__fiq:  b     .                         // FIQ
    904c:	eafffffe 	b	904c <__fiq>

00009050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
    9050:	e59f0228 	ldr	r0, [pc, #552]	; 9280 <.text+0x280>
		mrs   r1,CPSR
    9054:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
    9058:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
    905c:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
    9060:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
    9064:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
    9068:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
    906c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
    9070:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
    9074:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
    9078:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
    907c:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
    9080:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
    9084:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
    9088:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
    908c:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
    9090:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
    9094:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
    9098:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
    909c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
    90a0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
    90a4:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
    90a8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
    90ac:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
    90b0:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
    90b4:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
    90b8:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
    90bc:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
    90c0:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
    90c4:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
    90c8:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
    90cc:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
    90d0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
    90d4:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
    90d8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
    90dc:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -> not necessary, bootloader can be directly ecxecuted from ROM
// -----------------------------------------------------
//#ifdef ROM_RUN
//        ldr   r1,=_etext                // -> ROM data start
//        ldr   r2,=_data                 // -> data start
//        ldr   r3,=_edata                // -> end of data
//1:      cmp   r2,r3                     // check if data to move
//        ldrlo r0,[r1],#4                // copy it
//        strlo r0,[r2],#4
//        blo   1b                        // loop until done
//#endif

// Clear .bss
// Hell no!
// ----------
//        mov   r0,#0                     // get a zero
//        ldr   r1,=__bss_start           // -> bss start
//        ldr   r2,=__bss_end__           // -> bss end
//2:      cmp   r1,r2                     // check if data to clear
//        strlo r0,[r1],#4                // clear 4 bytes
//        blo   2b                        // loop until done

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
    90e0:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
    90e4:	e1a01000 	mov	r1, r0
        mov   r2,r0
    90e8:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
    90ec:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
    90f0:	e1a07000 	mov	r7, r0
        ldr   r10,=main
    90f4:	e59fa188 	ldr	sl, [pc, #392]	; 9284 <.text+0x284>
        mov   lr,pc
    90f8:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
    90fc:	e12fff1a 	bx	sl

00009100 <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
    9100:	eafffffe 	b	9100 <_reset>

00009104 <dab_handler>:

// Data Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
dab_handler:
		mov   r13, lr
    9104:	e1a0d00e 	mov	sp, lr
		mov   r4, #16
    9108:	e3a04010 	mov	r4, #16	; 0x10
		mcr   p15, 0, r4, c13, c13, 0
    910c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
    9110:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
    9114:	eb000051 	bl	9260 <uart0_send_byte>
		mov   r4, #'D'
    9118:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
    911c:	eb00004f 	bl	9260 <uart0_send_byte>
		mov   r4, #'A'
    9120:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
    9124:	eb00004d 	bl	9260 <uart0_send_byte>
		mov   r4, #'B'
    9128:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
    912c:	eb00004b 	bl	9260 <uart0_send_byte>
		b     isr_handler
    9130:	ea000022 	b	91c0 <isr_handler>

00009134 <iab_handler>:

// Instruction Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
iab_handler:
		mov   r13, lr
    9134:	e1a0d00e 	mov	sp, lr
		mov   r4, #32
    9138:	e3a04020 	mov	r4, #32	; 0x20
		mcr   p15, 0, r4, c13, c13, 0
    913c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
    9140:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
    9144:	eb000045 	bl	9260 <uart0_send_byte>
		mov   r4, #'I'
    9148:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
    914c:	eb000043 	bl	9260 <uart0_send_byte>
		mov   r4, #'A'
    9150:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
    9154:	eb000041 	bl	9260 <uart0_send_byte>
		mov   r4, #'B'
    9158:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
    915c:	eb00003f 	bl	9260 <uart0_send_byte>
		b     isr_handler
    9160:	ea000016 	b	91c0 <isr_handler>

00009164 <swi_handler>:

// Software Interrupt Handler
// -------------------------------------------------------------------
swi_handler:
		mov   r13, lr
    9164:	e1a0d00e 	mov	sp, lr
		mov   r4, #64
    9168:	e3a04040 	mov	r4, #64	; 0x40
		mcr   p15, 0, r4, c13, c13, 0
    916c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
    9170:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
    9174:	eb000039 	bl	9260 <uart0_send_byte>
		mov   r4, #'S'
    9178:	e3a04053 	mov	r4, #83	; 0x53
		bl    uart0_send_byte
    917c:	eb000037 	bl	9260 <uart0_send_byte>
		mov   r4, #'W'
    9180:	e3a04057 	mov	r4, #87	; 0x57
		bl    uart0_send_byte
    9184:	eb000035 	bl	9260 <uart0_send_byte>
		mov   r4, #'I'
    9188:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
    918c:	eb000033 	bl	9260 <uart0_send_byte>
		b     isr_handler
    9190:	ea00000a 	b	91c0 <isr_handler>

00009194 <und_handler>:

// Undefined Instruction Interrupt Handler
// -------------------------------------------------------------------
und_handler:
		mov   r13, lr
    9194:	e1a0d00e 	mov	sp, lr
		mov   r4, #128
    9198:	e3a04080 	mov	r4, #128	; 0x80
		mcr   p15, 0, r4, c13, c13, 0
    919c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
    91a0:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
    91a4:	eb00002d 	bl	9260 <uart0_send_byte>
		mov   r4, #'U'
    91a8:	e3a04055 	mov	r4, #85	; 0x55
		bl    uart0_send_byte
    91ac:	eb00002b 	bl	9260 <uart0_send_byte>
		mov   r4, #'N'
    91b0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
    91b4:	eb000029 	bl	9260 <uart0_send_byte>
		mov   r4, #'D'
    91b8:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
    91bc:	eb000027 	bl	9260 <uart0_send_byte>

000091c0 <isr_handler>:

// Interrupt Handler
// -------------------------------------------------------------------
isr_handler:
		mov   r4, #'-'
    91c0:	e3a0402d 	mov	r4, #45	; 0x2d
		bl    uart0_send_byte
    91c4:	eb000025 	bl	9260 <uart0_send_byte>
		mov   r4, #'I'
    91c8:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
    91cc:	eb000023 	bl	9260 <uart0_send_byte>
		mov   r4, #'N'
    91d0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
    91d4:	eb000021 	bl	9260 <uart0_send_byte>
		mov   r4, #'T'
    91d8:	e3a04054 	mov	r4, #84	; 0x54
		bl    uart0_send_byte
    91dc:	eb00001f 	bl	9260 <uart0_send_byte>
		mov   r4, #' '
    91e0:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
    91e4:	eb00001d 	bl	9260 <uart0_send_byte>
		mov   r4, #'@'
    91e8:	e3a04040 	mov	r4, #64	; 0x40
		bl    uart0_send_byte
    91ec:	eb00001b 	bl	9260 <uart0_send_byte>

		sub   r7, r13, #4
    91f0:	e24d7004 	sub	r7, sp, #4	; 0x4
		bl    uart0_print_hex
    91f4:	eb00000a 	bl	9224 <uart0_print_hex>

		mov   r4, #' '
    91f8:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
    91fc:	eb000017 	bl	9260 <uart0_send_byte>
		mov   r4, #'['		
    9200:	e3a0405b 	mov	r4, #91	; 0x5b
		bl    uart0_send_byte
    9204:	eb000015 	bl	9260 <uart0_send_byte>

		mrc   p15,0,r7, c9, c9
    9208:	ee197f19 	mrc	15, 0, r7, cr9, cr9, {0}
		bl    uart0_print_hex
    920c:	eb000004 	bl	9224 <uart0_print_hex>

		mov   r4, #']'
    9210:	e3a0405d 	mov	r4, #93	; 0x5d
		bl    uart0_send_byte
    9214:	eb000011 	bl	9260 <uart0_send_byte>
		mov   r4, #'>'
    9218:	e3a0403e 	mov	r4, #62	; 0x3e
		bl    uart0_send_byte
    921c:	eb00000f 	bl	9260 <uart0_send_byte>
		b .
    9220:	eafffffe 	b	9220 <isr_handler+0x60>

00009224 <uart0_print_hex>:


// Send 32-bit HEX value via UART0
// -------------------------------------------------------------------
uart0_print_hex:
		mov   r9, lr // save link register
    9224:	e1a0900e 	mov	r9, lr
		mov   r8, #32
    9228:	e3a08020 	mov	r8, #32	; 0x20

0000922c <uart0_print_hex_loop>:

uart0_print_hex_loop:
		cmp   r8, #0
    922c:	e3580000 	cmp	r8, #0	; 0x0
		moveq pc, r9
    9230:	01a0f009 	moveq	pc, r9

		sub   r8, r8, #4
    9234:	e2488004 	sub	r8, r8, #4	; 0x4
		mov   r6, r7, lsr r8 // isolate 4-bit value
    9238:	e1a06837 	mov	r6, r7, lsr r8
		and   r6, r6, #0x0F
    923c:	e206600f 	and	r6, r6, #15	; 0xf

		cmp   r6, #9
    9240:	e3560009 	cmp	r6, #9	; 0x9
		bgt   adapt_char
    9244:	ca000001 	bgt	9250 <adapt_char>
		add   r4, r6, #'0'
    9248:	e2864030 	add	r4, r6, #48	; 0x30

		b     uart0_print_hex_char
    924c:	ea000001 	b	9258 <uart0_print_hex_char>

00009250 <adapt_char>:
adapt_char:
		sub   r6, r6, #10
    9250:	e246600a 	sub	r6, r6, #10	; 0xa
		add   r4, r6, #'A'
    9254:	e2864041 	add	r4, r6, #65	; 0x41

00009258 <uart0_print_hex_char>:

uart0_print_hex_char:
		bl    uart0_send_byte
    9258:	eb000000 	bl	9260 <uart0_send_byte>
		b     uart0_print_hex_loop
    925c:	eafffff2 	b	922c <uart0_print_hex_loop>

00009260 <uart0_send_byte>:


// Send one char via UART0
// -------------------------------------------------------------------
uart0_send_byte:
		ldr   r0, =(0xFFFF001C)
    9260:	e59f0020 	ldr	r0, [pc, #32]	; 9288 <.text+0x288>
		ldr   r0, [r0]
    9264:	e5900000 	ldr	r0, [r0]
		and   r0, r0, #0x01
    9268:	e2000001 	and	r0, r0, #1	; 0x1
		cmp   r0, #0
    926c:	e3500000 	cmp	r0, #0	; 0x0
		beq   uart0_send_byte
    9270:	0afffffa 	beq	9260 <uart0_send_byte>
		ldr   r0, =(0xFFFF0018)
    9274:	e59f0010 	ldr	r0, [pc, #16]	; 928c <.text+0x28c>
		str   r4, [r0]
    9278:	e5804000 	str	r4, [r0]
		mov   pc, lr
    927c:	e1a0f00e 	mov	pc, lr
    9280:	0000db00 	andeq	sp, r0, r0, lsl #22
    9284:	00009964 	andeq	r9, r0, r4, ror #18
    9288:	ffff001c 	undefined instruction 0xffff001c
    928c:	ffff0018 	undefined instruction 0xffff0018

00009290 <io_read_gpio0_pin>:
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN & (1<<pin);
    9290:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    9294:	e5131ffb 	ldr	r1, [r3, #-4091]
    9298:	e20020ff 	and	r2, r0, #255	; 0xff
	
//	set_cmsr(_cmsr);
	return temp;
}
    929c:	e3a00001 	mov	r0, #1	; 0x1
    92a0:	e0010210 	and	r0, r1, r0, lsl r2
    92a4:	e12fff1e 	bx	lr

000092a8 <io_read_gpio0_port>:

// ******************************************************************************
// Read general purpose IO port
   unsigned long io_read_gpio0_port(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN;
    92a8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    92ac:	e5130ffb 	ldr	r0, [r3, #-4091]

//	set_cmsr(_cmsr);
	return temp;
}
    92b0:	e12fff1e 	bx	lr

000092b4 <io_set_gpio0_pin>:

// ******************************************************************************
// Set general purpose IO port
   void io_set_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT | (1<<pin);
    92b4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
    92b8:	e5113fff 	ldr	r3, [r1, #-4095]
    92bc:	e20000ff 	and	r0, r0, #255	; 0xff
    92c0:	e3a02001 	mov	r2, #1	; 0x1
    92c4:	e1833012 	orr	r3, r3, r2, lsl r0
    92c8:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
    92cc:	e12fff1e 	bx	lr

000092d0 <io_clr_gpio0_pin>:

// ******************************************************************************
// Clear general purpose IO port
   void io_clr_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
    92d0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
    92d4:	e3a02001 	mov	r2, #1	; 0x1
    92d8:	e1a02012 	mov	r2, r2, lsl r0
    92dc:	e3e01a0f 	mvn	r1, #61440	; 0xf000
    92e0:	e5113fff 	ldr	r3, [r1, #-4095]
    92e4:	e1e02002 	mvn	r2, r2
    92e8:	e0033002 	and	r3, r3, r2
    92ec:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
    92f0:	e12fff1e 	bx	lr

000092f4 <io_toggle_gpio0_pin>:
// ******************************************************************************
// Set general purpose IO port
   void io_toggle_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
    92f4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
    92f8:	e5113fff 	ldr	r3, [r1, #-4095]
    92fc:	e20000ff 	and	r0, r0, #255	; 0xff
    9300:	e3a02001 	mov	r2, #1	; 0x1
    9304:	e0233012 	eor	r3, r3, r2, lsl r0
    9308:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
    930c:	e12fff1e 	bx	lr

00009310 <io_set_gpio0_port>:

// ******************************************************************************
// Clear general purpose IO port
   void io_set_gpio0_port(unsigned long value)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
    9310:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    9314:	e5030fff 	str	r0, [r3, #-4095]

//	set_cmsr(_cmsr);
}
    9318:	e12fff1e 	bx	lr

0000931c <io_set_pwm>:



// ###########################################################################################################################
// Pulse-Width-Modulation Controller
// ###########################################################################################################################

// ******************************************************************************
// Set pwm value
   void io_set_pwm(unsigned char port, unsigned char data)
// ******************************************************************************
{
    931c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
    9320:	e3500007 	cmp	r0, #7	; 0x7
    9324:	e92d4010 	stmdb	sp!, {r4, lr}
    9328:	e3a0c000 	mov	ip, #0	; 0x0
    932c:	e3e0e0ff 	mvn	lr, #255	; 0xff
    9330:	e20110ff 	and	r1, r1, #255	; 0xff
    9334:	8a000011 	bhi	9380 <io_set_pwm+0x64>
		port = 0;

	if(port < 4){
		temp = PWM0_CONF0; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
		PWM0_CONF0 = temp;
	}
	else{
		port = port-4;
		temp = PWM0_CONF1; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
    9338:	e2403004 	sub	r3, r0, #4	; 0x4
    933c:	e20330ff 	and	r3, r3, #255	; 0xff
    9340:	e3500003 	cmp	r0, #3	; 0x3
    9344:	e1a0e183 	mov	lr, r3, lsl #3
    9348:	e3e04a0f 	mvn	r4, #61440	; 0xf000
    934c:	e1a0c180 	mov	ip, r0, lsl #3
    9350:	9a000007 	bls	9374 <io_set_pwm+0x58>
    9354:	e3a030ff 	mov	r3, #255	; 0xff
    9358:	e1a03e13 	mov	r3, r3, lsl lr
    935c:	e5142f8b 	ldr	r2, [r4, #-3979]
    9360:	e1e03003 	mvn	r3, r3
    9364:	e0022003 	and	r2, r2, r3
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
    9368:	e1822e11 	orr	r2, r2, r1, lsl lr
		PWM0_CONF1 = temp;
    936c:	e5042f8b 	str	r2, [r4, #-3979]
    9370:	e8bd8010 	ldmia	sp!, {r4, pc}
    9374:	e3a030ff 	mov	r3, #255	; 0xff
    9378:	e1a03c13 	mov	r3, r3, lsl ip
    937c:	e1e0e003 	mvn	lr, r3
    9380:	e3e02a0f 	mvn	r2, #61440	; 0xf000
    9384:	e5123f8f 	ldr	r3, [r2, #-3983]
    9388:	e003300e 	and	r3, r3, lr
    938c:	e1833c11 	orr	r3, r3, r1, lsl ip
    9390:	e5023f8f 	str	r3, [r2, #-3983]
    9394:	e8bd8010 	ldmia	sp!, {r4, pc}

00009398 <io_get_pwm>:
	}
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Set pwm value
   unsigned char io_get_pwm(unsigned char port)
// ******************************************************************************
{
    9398:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
    939c:	e3500007 	cmp	r0, #7	; 0x7
    93a0:	e3a02000 	mov	r2, #0	; 0x0
    93a4:	8a00000a 	bhi	93d4 <io_get_pwm+0x3c>
		port = 0;

	if(port < 4)
		temp = PWM0_CONF0; // get config register
	else{
		port = port-4;
		temp = PWM0_CONF1; // get config register
    93a8:	e2403004 	sub	r3, r0, #4	; 0x4
    93ac:	e3500003 	cmp	r0, #3	; 0x3
    93b0:	e20320ff 	and	r2, r3, #255	; 0xff
    93b4:	9a000005 	bls	93d0 <io_get_pwm+0x38>
    93b8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    93bc:	e5130f8b 	ldr	r0, [r3, #-3979]
    93c0:	e1a02182 	mov	r2, r2, lsl #3
    93c4:	e1a00230 	mov	r0, r0, lsr r2
    93c8:	e20000ff 	and	r0, r0, #255	; 0xff
	}

	temp = temp >> (port*8); // only keep designated byte

//	set_cmsr(_cmsr);
	return (unsigned char)temp;
}
    93cc:	e12fff1e 	bx	lr
    93d0:	e1a02180 	mov	r2, r0, lsl #3
    93d4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    93d8:	e5130f8f 	ldr	r0, [r3, #-3983]
    93dc:	e1a00230 	mov	r0, r0, lsr r2
    93e0:	e20000ff 	and	r0, r0, #255	; 0xff
    93e4:	e12fff1e 	bx	lr

000093e8 <io_uart0_read_byte>:



// ###########################################################################################################################
// General Purpose UART "miniUART" (UART_0)
// ###########################################################################################################################

// ******************************************************************************
// Read one byte via UART 0
   int io_uart0_read_byte(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
    93e8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
    93ec:	e5123fe3 	ldr	r3, [r2, #-4067]
    93f0:	e3130002 	tst	r3, #2	; 0x2
    93f4:	e3e00000 	mvn	r0, #0	; 0x0
		temp = UART0_DATA;
    93f8:	15120fe7 	ldrne	r0, [r2, #-4071]
	else
		temp = -1;

//	set_cmsr(_cmsr);
	return temp;
}
    93fc:	e12fff1e 	bx	lr

00009400 <io_uart0_send_byte>:

// ******************************************************************************
// Write one byte via UART 0
   int io_uart0_send_byte(int ch)
// ******************************************************************************
{
    9400:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
    9404:	e5123fe3 	ldr	r3, [r2, #-4067]
    9408:	e3130001 	tst	r3, #1	; 0x1
    940c:	0afffffc 	beq	9404 <io_uart0_send_byte+0x4>
	UART0_DATA = (ch & 0x000000FF);
    9410:	e20030ff 	and	r3, r0, #255	; 0xff
    9414:	e5023fe7 	str	r3, [r2, #-4071]

//	set_cmsr(_cmsr);
	return ch;
}
    9418:	e12fff1e 	bx	lr

0000941c <io_spi0_config>:



// ###########################################################################################################################
// Serial Peripherial Interface (SPI_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0
   void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
// ******************************************************************************
{
    941c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
	// devices update their serial input on a rising edge of sclk,
	// so we need to update the mosi output of the core before
	// -> at the falling edge of sclk = set SPI_TX_NEG
	if(auto_cs == 1)
    9420:	e3500001 	cmp	r0, #1	; 0x1
		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
	else
		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
    9424:	e3812b01 	orr	r2, r1, #1024	; 0x400
    9428:	03e03a0f 	mvneq	r3, #61440	; 0xf000
    942c:	e3811b09 	orr	r1, r1, #9216	; 0x2400
    9430:	13e03a0f 	mvnne	r3, #61440	; 0xf000
    9434:	05031fcf 	streq	r1, [r3, #-4047]
    9438:	15032fcf 	strne	r2, [r3, #-4047]
    943c:	e12fff1e 	bx	lr

00009440 <io_spi0_speed>:
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
   void io_spi0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
    9440:	e3e03a0f 	mvn	r3, #61440	; 0xf000
    9444:	e5030fcb 	str	r0, [r3, #-4043]

//	set_cmsr(_cmsr);
}
    9448:	e12fff1e 	bx	lr

0000944c <io_spi0_trans>:

// ******************************************************************************
// Sends/receives max 32 bits via SPI, CS and config must be done outside
   unsigned long io_spi0_trans(unsigned long data)
// ******************************************************************************
{
    944c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
    9450:	e5123fcf 	ldr	r3, [r2, #-4047]
    9454:	e3130c01 	tst	r3, #256	; 0x100
    9458:	1afffffc 	bne	9450 <io_spi0_trans+0x4>
	SPI0_DAT0 = data;
    945c:	e5020fbf 	str	r0, [r2, #-4031]
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
    9460:	e5123fcf 	ldr	r3, [r2, #-4047]
    9464:	e3833c01 	orr	r3, r3, #256	; 0x100
    9468:	e5023fcf 	str	r3, [r2, #-4047]
    946c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
    9470:	e5123fcf 	ldr	r3, [r2, #-4047]
    9474:	e3130c01 	tst	r3, #256	; 0x100
    9478:	1afffffc 	bne	9470 <io_spi0_trans+0x24>
	unsigned long temp = SPI0_DAT0;
    947c:	e5120fbf 	ldr	r0, [r2, #-4031]

//	set_cmsr(_cmsr);
	return temp;
}
    9480:	e12fff1e 	bx	lr

00009484 <io_spi0_enable>:

// ******************************************************************************
// Controls the CS of SPI0, enables a connected CS (turns it LOW)
   void io_spi0_enable(unsigned char device)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR | (1<<device);
    9484:	e3e01a0f 	mvn	r1, #61440	; 0xf000
    9488:	e5113fc7 	ldr	r3, [r1, #-4039]
    948c:	e20000ff 	and	r0, r0, #255	; 0xff
    9490:	e3a02001 	mov	r2, #1	; 0x1
    9494:	e1833012 	orr	r3, r3, r2, lsl r0
    9498:	e5013fc7 	str	r3, [r1, #-4039]

//	set_cmsr(_cmsr);
}
    949c:	e12fff1e 	bx	lr

000094a0 <io_spi0_disable>:

// ******************************************************************************
// Controls the CS of SPI0, disables a connected CS (turns it HIGH)
   void io_spi0_disable(unsigned char device)
// ******************************************************************************
{
    94a0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
    94a4:	e3a02001 	mov	r2, #1	; 0x1
    94a8:	e1a02012 	mov	r2, r2, lsl r0
    94ac:	e3e01a0f 	mvn	r1, #61440	; 0xf000
    94b0:	e5113fc7 	ldr	r3, [r1, #-4039]
    94b4:	e1e02002 	mvn	r2, r2
    94b8:	e0033002 	and	r3, r3, r2
    94bc:	e5013fc7 	str	r3, [r1, #-4039]

//	set_cmsr(_cmsr);
}
    94c0:	e12fff1e 	bx	lr

000094c4 <io_i2c0_speed>:




// ###########################################################################################################################
// Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
   void io_i2c0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
    94c4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
    94c8:	e5123f97 	ldr	r3, [r2, #-3991]
		I2C0_PRLO = clk_divider;
		I2C0_PRHI = clk_divider >> 8;
    94cc:	e1a01420 	mov	r1, r0, lsr #8
    94d0:	e3c33080 	bic	r3, r3, #128	; 0x80
    94d4:	e5023f97 	str	r3, [r2, #-3991]
    94d8:	e5020f9f 	str	r0, [r2, #-3999]
    94dc:	e5021f9b 	str	r1, [r2, #-3995]
		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
    94e0:	e5123f97 	ldr	r3, [r2, #-3991]
    94e4:	e3833080 	orr	r3, r3, #128	; 0x80
    94e8:	e5023f97 	str	r3, [r2, #-3991]
//	set_cmsr(_cmsr);
}
    94ec:	e12fff1e 	bx	lr

000094f0 <io_i2c0_byte_transfer>:

// ******************************************************************************
// Read/write byte from/to I²C slave, max 2 address bytes
   int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
                             unsigned char id,        // device ID
							 unsigned long data_adr,  // data address
							 unsigned char adr_bytes, // number of adr bytes
							 unsigned char data)      // data byte
// ******************************************************************************
{
    94f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
    94f4:	e3a0c090 	mov	ip, #144	; 0x90
    94f8:	e20140fe 	and	r4, r1, #254	; 0xfe
    94fc:	e3e0ea0f 	mvn	lr, #61440	; 0xf000
    9500:	e5dd500f 	ldrb	r5, [sp, #15]
    9504:	e20000ff 	and	r0, r0, #255	; 0xff
    9508:	e50e4f93 	str	r4, [lr, #-3987]
    950c:	e20110ff 	and	r1, r1, #255	; 0xff
    9510:	e50ecfaf 	str	ip, [lr, #-4015]
    9514:	e1a04002 	mov	r4, r2
    9518:	e203c0ff 	and	ip, r3, #255	; 0xff
	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
    951c:	e51e3faf 	ldr	r3, [lr, #-4015]
    9520:	e3130002 	tst	r3, #2	; 0x2
    9524:	1afffffc 	bne	951c <io_i2c0_byte_transfer+0x2c>
	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
    9528:	e51e3faf 	ldr	r3, [lr, #-4015]
    952c:	e3130080 	tst	r3, #128	; 0x80
    9530:	13e00000 	mvnne	r0, #0	; 0x0
    9534:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
    9538:	e35c0000 	cmp	ip, #0	; 0x0
    953c:	0a000012 	beq	958c <io_i2c0_byte_transfer+0x9c>
		adr_bytes--;
    9540:	e24c3001 	sub	r3, ip, #1	; 0x1
    9544:	e203c0ff 	and	ip, r3, #255	; 0xff
		if(adr_bytes == 1)
    9548:	e35c0001 	cmp	ip, #1	; 0x1
			I2C0_DATA = data_adr >> 8;          // high byte
    954c:	01a02424 	moveq	r2, r4, lsr #8
    9550:	03e03a0f 	mvneq	r3, #61440	; 0xf000
		else
			I2C0_DATA = data_adr;               // low byte
    9554:	13e03a0f 	mvnne	r3, #61440	; 0xf000
    9558:	05032f93 	streq	r2, [r3, #-3987]
    955c:	15034f93 	strne	r4, [r3, #-3987]
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
    9560:	e3e02a0f 	mvn	r2, #61440	; 0xf000
    9564:	e3a03010 	mov	r3, #16	; 0x10
    9568:	e5023faf 	str	r3, [r2, #-4015]
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
    956c:	e5123faf 	ldr	r3, [r2, #-4015]
    9570:	e3130002 	tst	r3, #2	; 0x2
    9574:	1afffffc 	bne	956c <io_i2c0_byte_transfer+0x7c>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
    9578:	e5123faf 	ldr	r3, [r2, #-4015]
    957c:	e3130080 	tst	r3, #128	; 0x80
    9580:	0affffec 	beq	9538 <io_i2c0_byte_transfer+0x48>
    9584:	e3e00001 	mvn	r0, #1	; 0x1
    9588:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -2;
		}
	}

	if(rw == 'w'){
    958c:	e3500077 	cmp	r0, #119	; 0x77
    9590:	1a00000c 	bne	95c8 <io_i2c0_byte_transfer+0xd8>
		// write adressed byte
		I2C0_DATA = data;                       // send data
    9594:	e3e03a0f 	mvn	r3, #61440	; 0xf000
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
    9598:	e3a02050 	mov	r2, #80	; 0x50
    959c:	e5035f93 	str	r5, [r3, #-3987]
    95a0:	e5032faf 	str	r2, [r3, #-4015]
    95a4:	e1a02003 	mov	r2, r3
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
    95a8:	e5123faf 	ldr	r3, [r2, #-4015]
    95ac:	e3130002 	tst	r3, #2	; 0x2
    95b0:	1afffffc 	bne	95a8 <io_i2c0_byte_transfer+0xb8>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
    95b4:	e5123faf 	ldr	r3, [r2, #-4015]
    95b8:	e2130080 	ands	r0, r3, #128	; 0x80
    95bc:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -3;
		}
		else{
//			set_cmsr(_cmsr);
			return 0;
		}
	}

	if(rw == 'r'){
		// re-send control byte - this time with read-bit
		I2C0_DATA = id | 0x01;                  // device id and READ
		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
//			set_cmsr(_cmsr);
			return -3;
		}
		// read adressed byte
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		return I2C0_DATA;
    95c0:	e3e00002 	mvn	r0, #2	; 0x2
	}

//	set_cmsr(_cmsr);
	return -4;
}
    95c4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
    95c8:	e3500072 	cmp	r0, #114	; 0x72
    95cc:	13e00003 	mvnne	r0, #3	; 0x3
    95d0:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
    95d4:	e3813001 	orr	r3, r1, #1	; 0x1
    95d8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
    95dc:	e3a01090 	mov	r1, #144	; 0x90
    95e0:	e5023f93 	str	r3, [r2, #-3987]
    95e4:	e5021faf 	str	r1, [r2, #-4015]
    95e8:	e5123faf 	ldr	r3, [r2, #-4015]
    95ec:	e3130002 	tst	r3, #2	; 0x2
    95f0:	1afffffc 	bne	95e8 <io_i2c0_byte_transfer+0xf8>
    95f4:	e5123faf 	ldr	r3, [r2, #-4015]
    95f8:	e3130080 	tst	r3, #128	; 0x80
    95fc:	1affffef 	bne	95c0 <io_i2c0_byte_transfer+0xd0>
    9600:	e3a03068 	mov	r3, #104	; 0x68
    9604:	e5023faf 	str	r3, [r2, #-4015]
    9608:	e3e00a0f 	mvn	r0, #61440	; 0xf000
    960c:	e5103faf 	ldr	r3, [r0, #-4015]
    9610:	e3130002 	tst	r3, #2	; 0x2
    9614:	1afffffc 	bne	960c <io_i2c0_byte_transfer+0x11c>
    9618:	e5100f93 	ldr	r0, [r0, #-3987]
    961c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00009620 <get_syscpreg>:




// ###########################################################################################################################
// System
// ###########################################################################################################################

// ******************************************************************************
// read system coprocessor register x
   unsigned long get_syscpreg(unsigned char index)
// ******************************************************************************
{
    9620:	e20000ff 	and	r0, r0, #255	; 0xff
	unsigned long _cp_val;
	switch(index){
    9624:	e350000f 	cmp	r0, #15	; 0xf
    9628:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
    962c:	ea00000f 	b	9670 <.text+0x670>
    9630:	000096f0 	streqd	r9, [r0], -r0
    9634:	000096e8 	andeq	r9, r0, r8, ror #13
    9638:	000096e0 	andeq	r9, r0, r0, ror #13
    963c:	000096d8 	ldreqd	r9, [r0], -r8
    9640:	000096d0 	ldreqd	r9, [r0], -r0
    9644:	000096c8 	andeq	r9, r0, r8, asr #13
    9648:	000096c0 	andeq	r9, r0, r0, asr #13
    964c:	000096b8 	streqh	r9, [r0], -r8
    9650:	000096b0 	streqh	r9, [r0], -r0
    9654:	000096a8 	andeq	r9, r0, r8, lsr #13
    9658:	000096a0 	andeq	r9, r0, r0, lsr #13
    965c:	00009698 	muleq	r0, r8, r6
    9660:	00009690 	muleq	r0, r0, r6
    9664:	00009688 	andeq	r9, r0, r8, lsl #13
    9668:	00009680 	andeq	r9, r0, r0, lsl #13
    966c:	00009678 	andeq	r9, r0, r8, ror r6
    9670:	e3a00000 	mov	r0, #0	; 0x0
    9674:	e12fff1e 	bx	lr
		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); break;
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); break;
    9678:	ee1f0f1f 	mrc	15, 0, r0, cr15, cr15, {0}
		default:         _cp_val = 0; break;
	}
	return _cp_val;
}
    967c:	e12fff1e 	bx	lr
    9680:	ee1e0f1e 	mrc	15, 0, r0, cr14, cr14, {0}
    9684:	e12fff1e 	bx	lr
    9688:	ee1d0f1d 	mrc	15, 0, r0, cr13, cr13, {0}
    968c:	e12fff1e 	bx	lr
    9690:	ee1c0f1c 	mrc	15, 0, r0, cr12, cr12, {0}
    9694:	e12fff1e 	bx	lr
    9698:	ee1b0f1b 	mrc	15, 0, r0, cr11, cr11, {0}
    969c:	e12fff1e 	bx	lr
    96a0:	ee1a0f1a 	mrc	15, 0, r0, cr10, cr10, {0}
    96a4:	e12fff1e 	bx	lr
    96a8:	ee190f19 	mrc	15, 0, r0, cr9, cr9, {0}
    96ac:	e12fff1e 	bx	lr
    96b0:	ee180f18 	mrc	15, 0, r0, cr8, cr8, {0}
    96b4:	e12fff1e 	bx	lr
    96b8:	ee170f17 	mrc	15, 0, r0, cr7, cr7, {0}
    96bc:	e12fff1e 	bx	lr
    96c0:	ee160f16 	mrc	15, 0, r0, cr6, cr6, {0}
    96c4:	e12fff1e 	bx	lr
    96c8:	ee150f15 	mrc	15, 0, r0, cr5, cr5, {0}
    96cc:	e12fff1e 	bx	lr
    96d0:	ee140f14 	mrc	15, 0, r0, cr4, cr4, {0}
    96d4:	e12fff1e 	bx	lr
    96d8:	ee130f13 	mrc	15, 0, r0, cr3, cr3, {0}
    96dc:	e12fff1e 	bx	lr
    96e0:	ee120f12 	mrc	15, 0, r0, cr2, cr2, {0}
    96e4:	e12fff1e 	bx	lr
    96e8:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
    96ec:	e12fff1e 	bx	lr
    96f0:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
    96f4:	e12fff1e 	bx	lr

000096f8 <set_syscpreg>:

// ******************************************************************************
// write system coprocessor register x
   void set_syscpreg(unsigned long _cp_val, unsigned char index)
// ******************************************************************************
{
    96f8:	e20110ff 	and	r1, r1, #255	; 0xff
	switch(index){
    96fc:	e2411006 	sub	r1, r1, #6	; 0x6
    9700:	e3510007 	cmp	r1, #7	; 0x7
    9704:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
    9708:	ea000008 	b	9730 <.text+0x730>
    970c:	00009734 	andeq	r9, r0, r4, lsr r7
    9710:	00009730 	andeq	r9, r0, r0, lsr r7
    9714:	00009730 	andeq	r9, r0, r0, lsr r7
    9718:	00009730 	andeq	r9, r0, r0, lsr r7
    971c:	00009730 	andeq	r9, r0, r0, lsr r7
    9720:	0000973c 	andeq	r9, r0, ip, lsr r7
    9724:	00009744 	andeq	r9, r0, r4, asr #14
    9728:	0000972c 	andeq	r9, r0, ip, lsr #14
//		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
    972c:	ee0d0f1d 	mcr	15, 0, r0, cr13, cr13, {0}
    9730:	e12fff1e 	bx	lr
    9734:	ee060f16 	mcr	15, 0, r0, cr6, cr6, {0}
    9738:	e12fff1e 	bx	lr
    973c:	ee0b0f1b 	mcr	15, 0, r0, cr11, cr11, {0}
    9740:	e12fff1e 	bx	lr
    9744:	ee0c0f1c 	mcr	15, 0, r0, cr12, cr12, {0}
    9748:	e12fff1e 	bx	lr

0000974c <io_enable_xint>:
//		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); break;
		default:         break;
	}
}
// ******************************************************************************
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
    974c:	e10f3000 	mrs	r3, CPSR
	return _cmsr;
}

// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
    9750:	e3c330c0 	bic	r3, r3, #192	; 0xc0
    9754:	e129f003 	msr	CPSR_fc, r3
}

// ******************************************************************************
// Enable all external INTs
   void io_enable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
    9758:	e12fff1e 	bx	lr

0000975c <io_disable_xint>:
    975c:	e10f3000 	mrs	r3, CPSR
    9760:	e38330c0 	orr	r3, r3, #192	; 0xc0
    9764:	e129f003 	msr	CPSR_fc, r3

// ******************************************************************************
// Disable all global IBTs
   void io_disable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
    9768:	e12fff1e 	bx	lr

0000976c <long_to_hex_string>:
   void long_to_hex_string(unsigned long data,    // max 32 bit data word
                           unsigned char *buffer, // buffer to store the string
						   unsigned char numbers) // number of places, max 8
// ############################################################################################
{
    976c:	e92d4010 	stmdb	sp!, {r4, lr}
    9770:	e20240ff 	and	r4, r2, #255	; 0xff
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
    9774:	e3540008 	cmp	r4, #8	; 0x8
    9778:	83a04008 	movhi	r4, #8	; 0x8
    977c:	8a000001 	bhi	9788 <long_to_hex_string+0x1c>
		numbers = 8;
	if(numbers < 1)
    9780:	e3540000 	cmp	r4, #0	; 0x0
		numbers = 1;

	while(numbers > 0){
		// isolate one 4-bit value
		if(numbers > 1)
			temp_data = data >> ((numbers-1)*4);
		else
			temp_data = data;
		temp_data = temp_data & 0x0000000F;
		numbers--;

		// convert 4-bit value temp_data to char temp_char
		if(temp_data < 10)
			temp_char = '0' + temp_data;
		else
			temp_char = 'A' + temp_data - 10;

		// save character
		*buffer++ = temp_char;
	}

	*buffer++ = 0; // terminate string
}
    9784:	03a04001 	moveq	r4, #1	; 0x1
    9788:	e1a02001 	mov	r2, r1
    978c:	e1a0e004 	mov	lr, r4
    9790:	e1a0310e 	mov	r3, lr, lsl #2
    9794:	e35e0001 	cmp	lr, #1	; 0x1
    9798:	e2433004 	sub	r3, r3, #4	; 0x4
    979c:	e1a0c000 	mov	ip, r0
    97a0:	81a0c330 	movhi	ip, r0, lsr r3
    97a4:	e24e3001 	sub	r3, lr, #1	; 0x1
    97a8:	e20cc00f 	and	ip, ip, #15	; 0xf
    97ac:	e203e0ff 	and	lr, r3, #255	; 0xff
    97b0:	e35c0009 	cmp	ip, #9	; 0x9
    97b4:	e28c3030 	add	r3, ip, #48	; 0x30
    97b8:	828c3037 	addhi	r3, ip, #55	; 0x37
    97bc:	e35e0000 	cmp	lr, #0	; 0x0
    97c0:	e4c23001 	strb	r3, [r2], #1
    97c4:	1afffff1 	bne	9790 <long_to_hex_string+0x24>
    97c8:	e2443001 	sub	r3, r4, #1	; 0x1
    97cc:	e20330ff 	and	r3, r3, #255	; 0xff
    97d0:	e0813003 	add	r3, r1, r3
    97d4:	e5c3e001 	strb	lr, [r3, #1]
    97d8:	e8bd8010 	ldmia	sp!, {r4, pc}

000097dc <get_adc>:

// ############################################################################################
// read external ADC value
   unsigned int get_adc(int adc_index) // adc 0..7
// ############################################################################################
{
    97dc:	e92d4010 	stmdb	sp!, {r4, lr}
    97e0:	e1a04000 	mov	r4, r0
	unsigned long temp;

	if ((adc_index < 0) || (adc_index > 7))
    97e4:	e3540007 	cmp	r4, #7	; 0x7
		return 0;

	// config spi
	io_spi0_config(1,16); // auto assert cs, 16 bit transfer
    97e8:	e3a01010 	mov	r1, #16	; 0x10
    97ec:	e3a00001 	mov	r0, #1	; 0x1
    97f0:	9a000001 	bls	97fc <get_adc+0x20>
	io_spi0_enable(adc_cs);

	temp = adc_index * 2048;
	io_spi0_trans(0); // dummy read
	return (unsigned int)io_spi0_trans(temp);
}
    97f4:	e3a00000 	mov	r0, #0	; 0x0
    97f8:	e8bd8010 	ldmia	sp!, {r4, pc}
    97fc:	ebffff06 	bl	941c <io_spi0_config>
    9800:	e3a00006 	mov	r0, #6	; 0x6
    9804:	ebffff1e 	bl	9484 <io_spi0_enable>
    9808:	e3a00000 	mov	r0, #0	; 0x0
    980c:	ebffff0e 	bl	944c <io_spi0_trans>
    9810:	e1a00584 	mov	r0, r4, lsl #11
    9814:	e8bd4010 	ldmia	sp!, {r4, lr}
    9818:	eaffff0b 	b	944c <io_spi0_trans>

0000981c <delay>:

// ############################################################################################
// simple delay routine
   void delay(int time) // waits time*10000 clock ticks
// ############################################################################################
{
	time = time*2500*4;
    981c:	e0603280 	rsb	r3, r0, r0, lsl #5
    9820:	e0800103 	add	r0, r0, r3, lsl #2
    9824:	e0800100 	add	r0, r0, r0, lsl #2
    9828:	e1a00200 	mov	r0, r0, lsl #4
	while(time > 0){
    982c:	e3500000 	cmp	r0, #0	; 0x0
    9830:	d12fff1e 	bxle	lr
		asm volatile ("NOP");
    9834:	e1a00000 	nop			(mov r0,r0)
    9838:	e2500001 	subs	r0, r0, #1	; 0x1
    983c:	1afffffc 	bne	9834 <delay+0x18>
    9840:	e12fff1e 	bx	lr

00009844 <string_cmpc>:
		time--;
	}
}

// ############################################################################################
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
    9844:	e212c0ff 	ands	ip, r2, #255	; 0xff
    9848:	0a00000b 	beq	987c <string_cmpc+0x38>
		if(*string1++ != (unsigned char)*string2++)
    984c:	e5d02000 	ldrb	r2, [r0]
    9850:	e5d13000 	ldrb	r3, [r1]
    9854:	e1520003 	cmp	r2, r3
    9858:	0a000004 	beq	9870 <string_cmpc+0x2c>
    985c:	ea000008 	b	9884 <string_cmpc+0x40>
    9860:	e5f02001 	ldrb	r2, [r0, #1]!
    9864:	e5f13001 	ldrb	r3, [r1, #1]!
    9868:	e1520003 	cmp	r2, r3
    986c:	1a000004 	bne	9884 <string_cmpc+0x40>
			return(0); // missmatch
		length--;
    9870:	e24c3001 	sub	r3, ip, #1	; 0x1
    9874:	e213c0ff 	ands	ip, r3, #255	; 0xff
    9878:	1afffff8 	bne	9860 <string_cmpc+0x1c>
    987c:	e3a00001 	mov	r0, #1	; 0x1
	}
	return(1); // match
}
    9880:	e12fff1e 	bx	lr
    9884:	e3a00000 	mov	r0, #0	; 0x0
    9888:	e12fff1e 	bx	lr

0000988c <uart0_printf>:
// ############################################################################################
// Print text string via UART 0
   const char *uart0_printf(const char *string)
// ############################################################################################
{
    988c:	e92d4010 	stmdb	sp!, {r4, lr}
    9890:	e1a04000 	mov	r4, r0
	char ch;

	while ((ch = *string)){
    9894:	e5d00000 	ldrb	r0, [r0]
    9898:	e3500000 	cmp	r0, #0	; 0x0
    989c:	1a000003 	bne	98b0 <uart0_printf+0x24>
    98a0:	ea000005 	b	98bc <uart0_printf+0x30>
    98a4:	e5f40001 	ldrb	r0, [r4, #1]!
    98a8:	e3500000 	cmp	r0, #0	; 0x0
    98ac:	0a000002 	beq	98bc <uart0_printf+0x30>
		if (io_uart0_send_byte(ch)<=0)
    98b0:	ebfffed2 	bl	9400 <io_uart0_send_byte>
    98b4:	e3500000 	cmp	r0, #0	; 0x0
    98b8:	cafffff9 	bgt	98a4 <uart0_printf+0x18>
			break;
		string++;
	}
	return string;
}
    98bc:	e1a00004 	mov	r0, r4
    98c0:	e8bd8010 	ldmia	sp!, {r4, pc}

000098c4 <uart0_scanf>:

// ############################################################################################
// Read text string via UART 0
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
    98c4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	int temp = 0;

	while(length > 0){
    98c8:	e2514000 	subs	r4, r1, #0	; 0x0
    98cc:	e1a05000 	mov	r5, r0
    98d0:	e20260ff 	and	r6, r2, #255	; 0xff
    98d4:	d8bd8070 	ldmleia	sp!, {r4, r5, r6, pc}
		temp = io_uart0_read_byte();
    98d8:	ebfffec2 	bl	93e8 <io_uart0_read_byte>
		if(temp != -1){
    98dc:	e3700001 	cmn	r0, #1	; 0x1
			temp = (unsigned char)(temp & 0x000000FF);
    98e0:	e20030ff 	and	r3, r0, #255	; 0xff
    98e4:	0a000005 	beq	9900 <uart0_scanf+0x3c>
			*buffer++ = temp;
			if(en_echo == 1)
    98e8:	e3560001 	cmp	r6, #1	; 0x1
    98ec:	e5c53000 	strb	r3, [r5]
				io_uart0_send_byte(temp); // echo
    98f0:	e1a00003 	mov	r0, r3
    98f4:	e2855001 	add	r5, r5, #1	; 0x1
    98f8:	0a000003 	beq	990c <uart0_scanf+0x48>
			length--;
    98fc:	e2444001 	sub	r4, r4, #1	; 0x1
    9900:	e3540000 	cmp	r4, #0	; 0x0
    9904:	cafffff3 	bgt	98d8 <uart0_scanf+0x14>
    9908:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
    990c:	ebfffebb 	bl	9400 <io_uart0_send_byte>
    9910:	eafffff9 	b	98fc <uart0_scanf+0x38>

00009914 <uart0_print_buffer>:
		}
	}
}

// ############################################################################################
// Print character buffer via UART 0
   void uart0_print_buffer(unsigned char *buffer, int size)
// ############################################################################################
{
    9914:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	unsigned char char_buffer = 0;
	while(size > 0){
    9918:	e2514000 	subs	r4, r1, #0	; 0x0
    991c:	e1a05000 	mov	r5, r0
    9920:	d8bd8030 	ldmleia	sp!, {r4, r5, pc}
		char_buffer = *buffer++;
		io_uart0_send_byte((int)char_buffer);
    9924:	e4d50001 	ldrb	r0, [r5], #1
    9928:	ebfffeb4 	bl	9400 <io_uart0_send_byte>
    992c:	e2544001 	subs	r4, r4, #1	; 0x1
    9930:	1afffffb 	bne	9924 <uart0_print_buffer+0x10>
    9934:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00009938 <timer0_isr>:


/* ---- IRQ: Timer ISR ---- */
void __attribute__ ((interrupt("IRQ"))) timer0_isr(void)
{
    9938:	e24ee004 	sub	lr, lr, #4	; 0x4
    993c:	e92d500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
	// toggle status led
	set_syscpreg((get_syscpreg(SYS_IO) ^ 0x01), SYS_IO);
    9940:	e3a0000d 	mov	r0, #13	; 0xd
    9944:	ebffff35 	bl	9620 <get_syscpreg>
    9948:	e3a0100d 	mov	r1, #13	; 0xd
    994c:	e2200001 	eor	r0, r0, #1	; 0x1
    9950:	ebffff68 	bl	96f8 <set_syscpreg>

	// acknowledge interrupt
	VICVectAddr = 0;
    9954:	e3a02000 	mov	r2, #0	; 0x0
    9958:	e3e03000 	mvn	r3, #0	; 0x0
    995c:	e5032fcf 	str	r2, [r3, #-4047]
}
    9960:	e8fd900f 	ldmia	sp!, {r0, r1, r2, r3, ip, pc}^

00009964 <main>:


/* ---- Main function ---- */
int main(void)
{
	int temp;

	// timer init
	STME0_CNT  = 0;
	STME0_VAL  = 50000000; // threshold value for 1s ticks
    9964:	e3a027be 	mov	r2, #49807360	; 0x2f80000
    9968:	e2822a2f 	add	r2, r2, #192512	; 0x2f000
    996c:	e3e01a0f 	mvn	r1, #61440	; 0xf000
    9970:	e2822080 	add	r2, r2, #128	; 0x80
    9974:	e3a03000 	mov	r3, #0	; 0x0
    9978:	e5013fdf 	str	r3, [r1, #-4063]
    997c:	e5012fdb 	str	r2, [r1, #-4059]
	STME0_CONF = (1<<2) | (1<<1) | (1<<0); // interrupt en, auto reset, timer enable
	VICVectAddr0 = (unsigned long)timer0_isr;
    9980:	e59f205c 	ldr	r2, [pc, #92]	; 99e4 <.text+0x9e4>
    9984:	e3e00000 	mvn	r0, #0	; 0x0
    9988:	e2833007 	add	r3, r3, #7	; 0x7
    998c:	e5013fd7 	str	r3, [r1, #-4055]
    9990:	e5002fbf 	str	r2, [r0, #-4031]
	VICVectCntl0 = (1<<5) | 0; // enable and channel select = 0 (timer0)
    9994:	e2833019 	add	r3, r3, #25	; 0x19
	VICIntEnable = (1<<0); // enable channel 0 (timer0)
    9998:	e3a02001 	mov	r2, #1	; 0x1
    999c:	e5003f7f 	str	r3, [r0, #-3967]
    99a0:	e52de004 	str	lr, [sp, #-4]!
    99a4:	e5002fef 	str	r2, [r0, #-4079]
	io_enable_xint(); // enable IRQ
    99a8:	ebffff67 	bl	974c <io_enable_xint>

	// Intro
	uart0_printf("\r\n\r\nSTORM SoC Basic Configuration\r\n");
    99ac:	e59f0034 	ldr	r0, [pc, #52]	; 99e8 <.text+0x9e8>
    99b0:	ebffffb5 	bl	988c <uart0_printf>
	uart0_printf("Demo program\r\n\r\n");
    99b4:	e59f0030 	ldr	r0, [pc, #48]	; 99ec <.text+0x9ec>
    99b8:	ebffffb3 	bl	988c <uart0_printf>

	uart0_printf("Press any key!\r\n");
    99bc:	e59f002c 	ldr	r0, [pc, #44]	; 99f0 <.text+0x9f0>
    99c0:	ebffffb1 	bl	988c <uart0_printf>

	// echo received char
	while(1){
		temp = io_uart0_read_byte();
    99c4:	ebfffe87 	bl	93e8 <io_uart0_read_byte>
		if (temp != -1)
    99c8:	e3700001 	cmn	r0, #1	; 0x1
    99cc:	0afffffc 	beq	99c4 <main+0x60>
			io_uart0_send_byte(temp);
    99d0:	ebfffe8a 	bl	9400 <io_uart0_send_byte>
    99d4:	ebfffe83 	bl	93e8 <io_uart0_read_byte>
    99d8:	e3700001 	cmn	r0, #1	; 0x1
    99dc:	1afffffb 	bne	99d0 <main+0x6c>
    99e0:	eafffff7 	b	99c4 <main+0x60>
    99e4:	00009938 	andeq	r9, r0, r8, lsr r9
    99e8:	000099f4 	streqd	r9, [r0], -r4
    99ec:	00009a18 	andeq	r9, r0, r8, lsl sl
    99f0:	00009a2c 	andeq	r9, r0, ip, lsr #20
    99f4:	0d0a0d0a 	stceq	13, cr0, [sl, #-40]
    99f8:	53544f52 	cmppl	r4, #328	; 0x148
    99fc:	4d20536f 	stcmi	3, cr5, [r0, #-444]!
    9a00:	43204261 	teqmi	r0, #268435462	; 0x10000006
    9a04:	73696320 	cmnvc	r9, #-2147483648	; 0x80000000
    9a08:	436f6e66 	cmnmi	pc, #1632	; 0x660
    9a0c:	69677572 	stmvsdb	r7!, {r1, r4, r5, r6, r8, sl, ip, sp, lr}^
    9a10:	6174696f 	cmnvs	r4, pc, ror #18
    9a14:	6e0d0a00 	fmacsvs	s0, s26, s0
    9a18:	44656d6f 	strmibt	r6, [r5], #-3439
    9a1c:	2070726f 	rsbcss	r7, r0, pc, ror #4
    9a20:	6772616d 	ldrvsb	r6, [r2, -sp, ror #2]!
    9a24:	0d0a0d0a 	stceq	13, cr0, [sl, #-40]
    9a28:	00000000 	andeq	r0, r0, r0
    9a2c:	50726573 	rsbpls	r6, r2, r3, ror r5
    9a30:	7320616e 	teqvc	r0, #-2147483621	; 0x8000001b
    9a34:	79206b65 	stmvcdb	r0!, {r0, r2, r5, r6, r8, r9, fp, sp, lr}
    9a38:	79210d0a 	stmvcdb	r1!, {r1, r3, r8, sl, fp}
    9a3c:	00000000 	andeq	r0, r0, r0
