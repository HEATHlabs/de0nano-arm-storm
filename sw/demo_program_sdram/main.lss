
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000a40  01000000  01000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00004000  01000b00  01000b00  00008a40  2**0
                  ALLOC
  2 .comment      0000001b  00000000  00000000  00008a40  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000040  00000000  00000000  00008a60  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000243  00000000  00000000  00008aa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000792  00000000  00000000  00008ce3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000023b  00000000  00000000  00009475  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000002d0  00000000  00000000  000096b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  0000024c  00000000  00000000  00009980  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000002d2  00000000  00000000  00009bcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000006d6  00000000  00000000  00009e9e  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

01000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
 1000000:	ea000012 	b	1000050 <_mainCRTStartup>
        b     und_handler               // undefined - _undf
 1000004:	ea000062 	b	1000194 <und_handler>
        b     swi_handler               // SWI - _swi
 1000008:	ea000055 	b	1000164 <swi_handler>
        b     iab_handler               // program abort - _pabt
 100000c:	ea000048 	b	1000134 <iab_handler>
        b     iab_handler               // data abort - _dabt
 1000010:	ea000047 	b	1000134 <iab_handler>
        nop                             // reserved
 1000014:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
 1000018:	e51ffff0 	ldr	pc, [pc, #-4080]	; fff030 <STACK_SIZE+0xffb030>
        ldr   pc,[pc,#-0xFF0]           // FIQ - read the VIC
 100001c:	e51ffff0 	ldr	pc, [pc, #-4080]	; fff034 <STACK_SIZE+0xffb034>

01000020 <_undf>:
 1000020:	01000038 	tsteq	r0, r8, lsr r0

01000024 <_swi>:
 1000024:	0100003c 	tsteq	r0, ip, lsr r0

01000028 <_pabt>:
 1000028:	01000040 	tsteq	r0, r0, asr #32

0100002c <_dabt>:
 100002c:	01000044 	tsteq	r0, r4, asr #32

01000030 <_irq>:
 1000030:	01000048 	tsteq	r0, r8, asr #32

01000034 <_fiq>:
 1000034:	0100004c 	tsteq	r0, ip, asr #32

01000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
 1000038:	eafffffe 	b	1000038 <__undf>

0100003c <__swi>:
__swi:  b     .                         // SWI
 100003c:	eafffffe 	b	100003c <__swi>

01000040 <__pabt>:
__pabt: b     .                         // program abort
 1000040:	eafffffe 	b	1000040 <__pabt>

01000044 <__dabt>:
__dabt: b     .                         // data abort
 1000044:	eafffffe 	b	1000044 <__dabt>

01000048 <__irq>:
__irq:  b     .                         // IRQ
 1000048:	eafffffe 	b	1000048 <__irq>

0100004c <__fiq>:
__fiq:  b     .                         // FIQ
 100004c:	eafffffe 	b	100004c <__fiq>

01000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
 1000050:	e59f0228 	ldr	r0, [pc, #552]	; 1000280 <.text+0x280>
		mrs   r1,CPSR
 1000054:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
 1000058:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
 100005c:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
 1000060:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
 1000064:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
 1000068:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
 100006c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
 1000070:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
 1000074:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
 1000078:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
 100007c:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
 1000080:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
 1000084:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
 1000088:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
 100008c:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
 1000090:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
 1000094:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
 1000098:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
 100009c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
 10000a0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
 10000a4:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
 10000a8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
 10000ac:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
 10000b0:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
 10000b4:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
 10000b8:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
 10000bc:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
 10000c0:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
 10000c4:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
 10000c8:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
 10000cc:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
 10000d0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
 10000d4:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
 10000d8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
 10000dc:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -> not necessary, bootloader can be directly ecxecuted from ROM
// -----------------------------------------------------
//#ifdef ROM_RUN
//        ldr   r1,=_etext                // -> ROM data start
//        ldr   r2,=_data                 // -> data start
//        ldr   r3,=_edata                // -> end of data
//1:      cmp   r2,r3                     // check if data to move
//        ldrlo r0,[r1],#4                // copy it
//        strlo r0,[r2],#4
//        blo   1b                        // loop until done
//#endif

// Clear .bss
// Hell no!
// ----------
//        mov   r0,#0                     // get a zero
//        ldr   r1,=__bss_start           // -> bss start
//        ldr   r2,=__bss_end__           // -> bss end
//2:      cmp   r1,r2                     // check if data to clear
//        strlo r0,[r1],#4                // clear 4 bytes
//        blo   2b                        // loop until done

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
 10000e0:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
 10000e4:	e1a01000 	mov	r1, r0
        mov   r2,r0
 10000e8:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
 10000ec:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
 10000f0:	e1a07000 	mov	r7, r0
 //       ldr   r10,=main
//        mov   lr,pc
 //       b    r10                       // enter main()
//        bx    r10                       // enter main()
        ldr   r10,=main
 10000f4:	e59fa188 	ldr	sl, [pc, #392]	; 1000284 <.text+0x284>
        mov   lr,pc
 10000f8:	e1a0e00f 	mov	lr, pc
        mov   pc, r10                   // enter main()
 10000fc:	e1a0f00a 	mov	pc, sl

01000100 <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
 1000100:	eafffffe 	b	1000100 <_reset>

01000104 <dab_handler>:

// Data Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
dab_handler:
		mov   r13, lr
 1000104:	e1a0d00e 	mov	sp, lr
		mov   r4, #16
 1000108:	e3a04010 	mov	r4, #16	; 0x10
		mcr   p15, 0, r4, c13, c13, 0
 100010c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 1000110:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 1000114:	eb000051 	bl	1000260 <uart0_send_byte>
		mov   r4, #'D'
 1000118:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 100011c:	eb00004f 	bl	1000260 <uart0_send_byte>
		mov   r4, #'A'
 1000120:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 1000124:	eb00004d 	bl	1000260 <uart0_send_byte>
		mov   r4, #'B'
 1000128:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 100012c:	eb00004b 	bl	1000260 <uart0_send_byte>
		b     isr_handler
 1000130:	ea000022 	b	10001c0 <isr_handler>

01000134 <iab_handler>:

// Instruction Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
iab_handler:
		mov   r13, lr
 1000134:	e1a0d00e 	mov	sp, lr
		mov   r4, #32
 1000138:	e3a04020 	mov	r4, #32	; 0x20
		mcr   p15, 0, r4, c13, c13, 0
 100013c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 1000140:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 1000144:	eb000045 	bl	1000260 <uart0_send_byte>
		mov   r4, #'I'
 1000148:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 100014c:	eb000043 	bl	1000260 <uart0_send_byte>
		mov   r4, #'A'
 1000150:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 1000154:	eb000041 	bl	1000260 <uart0_send_byte>
		mov   r4, #'B'
 1000158:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 100015c:	eb00003f 	bl	1000260 <uart0_send_byte>
		b     isr_handler
 1000160:	ea000016 	b	10001c0 <isr_handler>

01000164 <swi_handler>:

// Software Interrupt Handler
// -------------------------------------------------------------------
swi_handler:
		mov   r13, lr
 1000164:	e1a0d00e 	mov	sp, lr
		mov   r4, #64
 1000168:	e3a04040 	mov	r4, #64	; 0x40
		mcr   p15, 0, r4, c13, c13, 0
 100016c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 1000170:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 1000174:	eb000039 	bl	1000260 <uart0_send_byte>
		mov   r4, #'S'
 1000178:	e3a04053 	mov	r4, #83	; 0x53
		bl    uart0_send_byte
 100017c:	eb000037 	bl	1000260 <uart0_send_byte>
		mov   r4, #'W'
 1000180:	e3a04057 	mov	r4, #87	; 0x57
		bl    uart0_send_byte
 1000184:	eb000035 	bl	1000260 <uart0_send_byte>
		mov   r4, #'I'
 1000188:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 100018c:	eb000033 	bl	1000260 <uart0_send_byte>
		b     isr_handler
 1000190:	ea00000a 	b	10001c0 <isr_handler>

01000194 <und_handler>:

// Undefined Instruction Interrupt Handler
// -------------------------------------------------------------------
und_handler:
		mov   r13, lr
 1000194:	e1a0d00e 	mov	sp, lr
		mov   r4, #128
 1000198:	e3a04080 	mov	r4, #128	; 0x80
		mcr   p15, 0, r4, c13, c13, 0
 100019c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 10001a0:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 10001a4:	eb00002d 	bl	1000260 <uart0_send_byte>
		mov   r4, #'U'
 10001a8:	e3a04055 	mov	r4, #85	; 0x55
		bl    uart0_send_byte
 10001ac:	eb00002b 	bl	1000260 <uart0_send_byte>
		mov   r4, #'N'
 10001b0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 10001b4:	eb000029 	bl	1000260 <uart0_send_byte>
		mov   r4, #'D'
 10001b8:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 10001bc:	eb000027 	bl	1000260 <uart0_send_byte>

010001c0 <isr_handler>:

// Interrupt Handler
// -------------------------------------------------------------------
isr_handler:
		mov   r4, #'-'
 10001c0:	e3a0402d 	mov	r4, #45	; 0x2d
		bl    uart0_send_byte
 10001c4:	eb000025 	bl	1000260 <uart0_send_byte>
		mov   r4, #'I'
 10001c8:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 10001cc:	eb000023 	bl	1000260 <uart0_send_byte>
		mov   r4, #'N'
 10001d0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 10001d4:	eb000021 	bl	1000260 <uart0_send_byte>
		mov   r4, #'T'
 10001d8:	e3a04054 	mov	r4, #84	; 0x54
		bl    uart0_send_byte
 10001dc:	eb00001f 	bl	1000260 <uart0_send_byte>
		mov   r4, #' '
 10001e0:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
 10001e4:	eb00001d 	bl	1000260 <uart0_send_byte>
		mov   r4, #'@'
 10001e8:	e3a04040 	mov	r4, #64	; 0x40
		bl    uart0_send_byte
 10001ec:	eb00001b 	bl	1000260 <uart0_send_byte>

		sub   r7, r13, #4
 10001f0:	e24d7004 	sub	r7, sp, #4	; 0x4
		bl    uart0_print_hex
 10001f4:	eb00000a 	bl	1000224 <uart0_print_hex>

		mov   r4, #' '
 10001f8:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
 10001fc:	eb000017 	bl	1000260 <uart0_send_byte>
		mov   r4, #'['		
 1000200:	e3a0405b 	mov	r4, #91	; 0x5b
		bl    uart0_send_byte
 1000204:	eb000015 	bl	1000260 <uart0_send_byte>

		mrc   p15,0,r7, c9, c9
 1000208:	ee197f19 	mrc	15, 0, r7, cr9, cr9, {0}
		bl    uart0_print_hex
 100020c:	eb000004 	bl	1000224 <uart0_print_hex>

		mov   r4, #']'
 1000210:	e3a0405d 	mov	r4, #93	; 0x5d
		bl    uart0_send_byte
 1000214:	eb000011 	bl	1000260 <uart0_send_byte>
		mov   r4, #'>'
 1000218:	e3a0403e 	mov	r4, #62	; 0x3e
		bl    uart0_send_byte
 100021c:	eb00000f 	bl	1000260 <uart0_send_byte>
		b .
 1000220:	eafffffe 	b	1000220 <isr_handler+0x60>

01000224 <uart0_print_hex>:


// Send 32-bit HEX value via UART0
// -------------------------------------------------------------------
uart0_print_hex:
		mov   r9, lr // save link register
 1000224:	e1a0900e 	mov	r9, lr
		mov   r8, #32
 1000228:	e3a08020 	mov	r8, #32	; 0x20

0100022c <uart0_print_hex_loop>:

uart0_print_hex_loop:
		cmp   r8, #0
 100022c:	e3580000 	cmp	r8, #0	; 0x0
		moveq pc, r9
 1000230:	01a0f009 	moveq	pc, r9

		sub   r8, r8, #4
 1000234:	e2488004 	sub	r8, r8, #4	; 0x4
		mov   r6, r7, lsr r8 // isolate 4-bit value
 1000238:	e1a06837 	mov	r6, r7, lsr r8
		and   r6, r6, #0x0F
 100023c:	e206600f 	and	r6, r6, #15	; 0xf

		cmp   r6, #9
 1000240:	e3560009 	cmp	r6, #9	; 0x9
		bgt   adapt_char
 1000244:	ca000001 	bgt	1000250 <adapt_char>
		add   r4, r6, #'0'
 1000248:	e2864030 	add	r4, r6, #48	; 0x30

		b     uart0_print_hex_char
 100024c:	ea000001 	b	1000258 <uart0_print_hex_char>

01000250 <adapt_char>:
adapt_char:
		sub   r6, r6, #10
 1000250:	e246600a 	sub	r6, r6, #10	; 0xa
		add   r4, r6, #'A'
 1000254:	e2864041 	add	r4, r6, #65	; 0x41

01000258 <uart0_print_hex_char>:

uart0_print_hex_char:
		bl    uart0_send_byte
 1000258:	eb000000 	bl	1000260 <uart0_send_byte>
		b     uart0_print_hex_loop
 100025c:	eafffff2 	b	100022c <uart0_print_hex_loop>

01000260 <uart0_send_byte>:


// Send one char via UART0
// -------------------------------------------------------------------
uart0_send_byte:
		ldr   r0, =(0xFFFF001C)
 1000260:	e59f0020 	ldr	r0, [pc, #32]	; 1000288 <.text+0x288>
		ldr   r0, [r0]
 1000264:	e5900000 	ldr	r0, [r0]
		and   r0, r0, #0x01
 1000268:	e2000001 	and	r0, r0, #1	; 0x1
		cmp   r0, #0
 100026c:	e3500000 	cmp	r0, #0	; 0x0
		beq   uart0_send_byte
 1000270:	0afffffa 	beq	1000260 <uart0_send_byte>
		ldr   r0, =(0xFFFF0018)
 1000274:	e59f0010 	ldr	r0, [pc, #16]	; 100028c <.text+0x28c>
		str   r4, [r0]
 1000278:	e5804000 	str	r4, [r0]
		mov   pc, lr
 100027c:	e1a0f00e 	mov	pc, lr
 1000280:	01004b00 	tsteq	r0, r0, lsl #22
 1000284:	01000964 	tsteq	r0, r4, ror #18
 1000288:	ffff001c 	undefined instruction 0xffff001c
 100028c:	ffff0018 	undefined instruction 0xffff0018

01000290 <io_read_gpio0_pin>:
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN & (1<<pin);
 1000290:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 1000294:	e5131ffb 	ldr	r1, [r3, #-4091]
 1000298:	e20020ff 	and	r2, r0, #255	; 0xff
	
//	set_cmsr(_cmsr);
	return temp;
}
 100029c:	e3a00001 	mov	r0, #1	; 0x1
 10002a0:	e0010210 	and	r0, r1, r0, lsl r2
 10002a4:	e1a0f00e 	mov	pc, lr

010002a8 <io_read_gpio0_port>:

// ******************************************************************************
// Read general purpose IO port
   unsigned long io_read_gpio0_port(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN;
 10002a8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 10002ac:	e5130ffb 	ldr	r0, [r3, #-4091]

//	set_cmsr(_cmsr);
	return temp;
}
 10002b0:	e1a0f00e 	mov	pc, lr

010002b4 <io_set_gpio0_pin>:

// ******************************************************************************
// Set general purpose IO port
   void io_set_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT | (1<<pin);
 10002b4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 10002b8:	e5113fff 	ldr	r3, [r1, #-4095]
 10002bc:	e20000ff 	and	r0, r0, #255	; 0xff
 10002c0:	e3a02001 	mov	r2, #1	; 0x1
 10002c4:	e1833012 	orr	r3, r3, r2, lsl r0
 10002c8:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 10002cc:	e1a0f00e 	mov	pc, lr

010002d0 <io_clr_gpio0_pin>:

// ******************************************************************************
// Clear general purpose IO port
   void io_clr_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
 10002d0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
 10002d4:	e3a02001 	mov	r2, #1	; 0x1
 10002d8:	e1a02012 	mov	r2, r2, lsl r0
 10002dc:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 10002e0:	e5113fff 	ldr	r3, [r1, #-4095]
 10002e4:	e1e02002 	mvn	r2, r2
 10002e8:	e0033002 	and	r3, r3, r2
 10002ec:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 10002f0:	e1a0f00e 	mov	pc, lr

010002f4 <io_toggle_gpio0_pin>:
// ******************************************************************************
// Set general purpose IO port
   void io_toggle_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 10002f4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 10002f8:	e5113fff 	ldr	r3, [r1, #-4095]
 10002fc:	e20000ff 	and	r0, r0, #255	; 0xff
 1000300:	e3a02001 	mov	r2, #1	; 0x1
 1000304:	e0233012 	eor	r3, r3, r2, lsl r0
 1000308:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 100030c:	e1a0f00e 	mov	pc, lr

01000310 <io_set_gpio0_port>:

// ******************************************************************************
// Clear general purpose IO port
   void io_set_gpio0_port(unsigned long value)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
 1000310:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 1000314:	e5030fff 	str	r0, [r3, #-4095]

//	set_cmsr(_cmsr);
}
 1000318:	e1a0f00e 	mov	pc, lr

0100031c <io_set_pwm>:



// ###########################################################################################################################
// Pulse-Width-Modulation Controller
// ###########################################################################################################################

// ******************************************************************************
// Set pwm value
   void io_set_pwm(unsigned char port, unsigned char data)
// ******************************************************************************
{
 100031c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 1000320:	e3500007 	cmp	r0, #7	; 0x7
 1000324:	e92d4010 	stmdb	sp!, {r4, lr}
 1000328:	e3a0c000 	mov	ip, #0	; 0x0
 100032c:	e3e0e0ff 	mvn	lr, #255	; 0xff
 1000330:	e20110ff 	and	r1, r1, #255	; 0xff
 1000334:	8a000011 	bhi	1000380 <io_set_pwm+0x64>
		port = 0;

	if(port < 4){
		temp = PWM0_CONF0; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
		PWM0_CONF0 = temp;
	}
	else{
		port = port-4;
		temp = PWM0_CONF1; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
 1000338:	e2403004 	sub	r3, r0, #4	; 0x4
 100033c:	e20330ff 	and	r3, r3, #255	; 0xff
 1000340:	e3500003 	cmp	r0, #3	; 0x3
 1000344:	e1a0e183 	mov	lr, r3, lsl #3
 1000348:	e3e04a0f 	mvn	r4, #61440	; 0xf000
 100034c:	e1a0c180 	mov	ip, r0, lsl #3
 1000350:	9a000007 	bls	1000374 <io_set_pwm+0x58>
 1000354:	e3a030ff 	mov	r3, #255	; 0xff
 1000358:	e1a03e13 	mov	r3, r3, lsl lr
 100035c:	e5142f8b 	ldr	r2, [r4, #-3979]
 1000360:	e1e03003 	mvn	r3, r3
 1000364:	e0022003 	and	r2, r2, r3
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 1000368:	e1822e11 	orr	r2, r2, r1, lsl lr
		PWM0_CONF1 = temp;
 100036c:	e5042f8b 	str	r2, [r4, #-3979]
 1000370:	e8bd8010 	ldmia	sp!, {r4, pc}
 1000374:	e3a030ff 	mov	r3, #255	; 0xff
 1000378:	e1a03c13 	mov	r3, r3, lsl ip
 100037c:	e1e0e003 	mvn	lr, r3
 1000380:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 1000384:	e5123f8f 	ldr	r3, [r2, #-3983]
 1000388:	e003300e 	and	r3, r3, lr
 100038c:	e1833c11 	orr	r3, r3, r1, lsl ip
 1000390:	e5023f8f 	str	r3, [r2, #-3983]
 1000394:	e8bd8010 	ldmia	sp!, {r4, pc}

01000398 <io_get_pwm>:
	}
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Set pwm value
   unsigned char io_get_pwm(unsigned char port)
// ******************************************************************************
{
 1000398:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 100039c:	e3500007 	cmp	r0, #7	; 0x7
 10003a0:	e3a02000 	mov	r2, #0	; 0x0
 10003a4:	8a00000a 	bhi	10003d4 <io_get_pwm+0x3c>
		port = 0;

	if(port < 4)
		temp = PWM0_CONF0; // get config register
	else{
		port = port-4;
		temp = PWM0_CONF1; // get config register
 10003a8:	e2403004 	sub	r3, r0, #4	; 0x4
 10003ac:	e3500003 	cmp	r0, #3	; 0x3
 10003b0:	e20320ff 	and	r2, r3, #255	; 0xff
 10003b4:	9a000005 	bls	10003d0 <io_get_pwm+0x38>
 10003b8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 10003bc:	e5130f8b 	ldr	r0, [r3, #-3979]
 10003c0:	e1a02182 	mov	r2, r2, lsl #3
 10003c4:	e1a00230 	mov	r0, r0, lsr r2
 10003c8:	e20000ff 	and	r0, r0, #255	; 0xff
	}

	temp = temp >> (port*8); // only keep designated byte

//	set_cmsr(_cmsr);
	return (unsigned char)temp;
}
 10003cc:	e1a0f00e 	mov	pc, lr
 10003d0:	e1a02180 	mov	r2, r0, lsl #3
 10003d4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 10003d8:	e5130f8f 	ldr	r0, [r3, #-3983]
 10003dc:	e1a00230 	mov	r0, r0, lsr r2
 10003e0:	e20000ff 	and	r0, r0, #255	; 0xff
 10003e4:	e1a0f00e 	mov	pc, lr

010003e8 <io_uart0_read_byte>:



// ###########################################################################################################################
// General Purpose UART "miniUART" (UART_0)
// ###########################################################################################################################

// ******************************************************************************
// Read one byte via UART 0
   int io_uart0_read_byte(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 10003e8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 10003ec:	e5123fe3 	ldr	r3, [r2, #-4067]
 10003f0:	e3130002 	tst	r3, #2	; 0x2
 10003f4:	e3e00000 	mvn	r0, #0	; 0x0
		temp = UART0_DATA;
 10003f8:	15120fe7 	ldrne	r0, [r2, #-4071]
	else
		temp = -1;

//	set_cmsr(_cmsr);
	return temp;
}
 10003fc:	e1a0f00e 	mov	pc, lr

01000400 <io_uart0_send_byte>:

// ******************************************************************************
// Write one byte via UART 0
   int io_uart0_send_byte(int ch)
// ******************************************************************************
{
 1000400:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 1000404:	e5123fe3 	ldr	r3, [r2, #-4067]
 1000408:	e3130001 	tst	r3, #1	; 0x1
 100040c:	0afffffc 	beq	1000404 <io_uart0_send_byte+0x4>
	UART0_DATA = (ch & 0x000000FF);
 1000410:	e20030ff 	and	r3, r0, #255	; 0xff
 1000414:	e5023fe7 	str	r3, [r2, #-4071]

//	set_cmsr(_cmsr);
	return ch;
}
 1000418:	e1a0f00e 	mov	pc, lr

0100041c <io_spi0_config>:



// ###########################################################################################################################
// Serial Peripherial Interface (SPI_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0
   void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
// ******************************************************************************
{
 100041c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
	// devices update their serial input on a rising edge of sclk,
	// so we need to update the mosi output of the core before
	// -> at the falling edge of sclk = set SPI_TX_NEG
	if(auto_cs == 1)
 1000420:	e3500001 	cmp	r0, #1	; 0x1
		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
	else
		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 1000424:	e3812b01 	orr	r2, r1, #1024	; 0x400
 1000428:	03e03a0f 	mvneq	r3, #61440	; 0xf000
 100042c:	e3811b09 	orr	r1, r1, #9216	; 0x2400
 1000430:	13e03a0f 	mvnne	r3, #61440	; 0xf000
 1000434:	05031fcf 	streq	r1, [r3, #-4047]
 1000438:	15032fcf 	strne	r2, [r3, #-4047]
 100043c:	e1a0f00e 	mov	pc, lr

01000440 <io_spi0_speed>:
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
   void io_spi0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 1000440:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 1000444:	e5030fcb 	str	r0, [r3, #-4043]

//	set_cmsr(_cmsr);
}
 1000448:	e1a0f00e 	mov	pc, lr

0100044c <io_spi0_trans>:

// ******************************************************************************
// Sends/receives max 32 bits via SPI, CS and config must be done outside
   unsigned long io_spi0_trans(unsigned long data)
// ******************************************************************************
{
 100044c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 1000450:	e5123fcf 	ldr	r3, [r2, #-4047]
 1000454:	e3130c01 	tst	r3, #256	; 0x100
 1000458:	1afffffc 	bne	1000450 <io_spi0_trans+0x4>
	SPI0_DAT0 = data;
 100045c:	e5020fbf 	str	r0, [r2, #-4031]
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 1000460:	e5123fcf 	ldr	r3, [r2, #-4047]
 1000464:	e3833c01 	orr	r3, r3, #256	; 0x100
 1000468:	e5023fcf 	str	r3, [r2, #-4047]
 100046c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 1000470:	e5123fcf 	ldr	r3, [r2, #-4047]
 1000474:	e3130c01 	tst	r3, #256	; 0x100
 1000478:	1afffffc 	bne	1000470 <io_spi0_trans+0x24>
	unsigned long temp = SPI0_DAT0;
 100047c:	e5120fbf 	ldr	r0, [r2, #-4031]

//	set_cmsr(_cmsr);
	return temp;
}
 1000480:	e1a0f00e 	mov	pc, lr

01000484 <io_spi0_enable>:

// ******************************************************************************
// Controls the CS of SPI0, enables a connected CS (turns it LOW)
   void io_spi0_enable(unsigned char device)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR | (1<<device);
 1000484:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 1000488:	e5113fc7 	ldr	r3, [r1, #-4039]
 100048c:	e20000ff 	and	r0, r0, #255	; 0xff
 1000490:	e3a02001 	mov	r2, #1	; 0x1
 1000494:	e1833012 	orr	r3, r3, r2, lsl r0
 1000498:	e5013fc7 	str	r3, [r1, #-4039]

//	set_cmsr(_cmsr);
}
 100049c:	e1a0f00e 	mov	pc, lr

010004a0 <io_spi0_disable>:

// ******************************************************************************
// Controls the CS of SPI0, disables a connected CS (turns it HIGH)
   void io_spi0_disable(unsigned char device)
// ******************************************************************************
{
 10004a0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 10004a4:	e3a02001 	mov	r2, #1	; 0x1
 10004a8:	e1a02012 	mov	r2, r2, lsl r0
 10004ac:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 10004b0:	e5113fc7 	ldr	r3, [r1, #-4039]
 10004b4:	e1e02002 	mvn	r2, r2
 10004b8:	e0033002 	and	r3, r3, r2
 10004bc:	e5013fc7 	str	r3, [r1, #-4039]

//	set_cmsr(_cmsr);
}
 10004c0:	e1a0f00e 	mov	pc, lr

010004c4 <io_i2c0_speed>:




// ###########################################################################################################################
// Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
   void io_i2c0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 10004c4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 10004c8:	e5123f97 	ldr	r3, [r2, #-3991]
		I2C0_PRLO = clk_divider;
		I2C0_PRHI = clk_divider >> 8;
 10004cc:	e1a01420 	mov	r1, r0, lsr #8
 10004d0:	e3c33080 	bic	r3, r3, #128	; 0x80
 10004d4:	e5023f97 	str	r3, [r2, #-3991]
 10004d8:	e5020f9f 	str	r0, [r2, #-3999]
 10004dc:	e5021f9b 	str	r1, [r2, #-3995]
		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 10004e0:	e5123f97 	ldr	r3, [r2, #-3991]
 10004e4:	e3833080 	orr	r3, r3, #128	; 0x80
 10004e8:	e5023f97 	str	r3, [r2, #-3991]
//	set_cmsr(_cmsr);
}
 10004ec:	e1a0f00e 	mov	pc, lr

010004f0 <io_i2c0_byte_transfer>:

// ******************************************************************************
// Read/write byte from/to I²C slave, max 2 address bytes
   int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
                             unsigned char id,        // device ID
							 unsigned long data_adr,  // data address
							 unsigned char adr_bytes, // number of adr bytes
							 unsigned char data)      // data byte
// ******************************************************************************
{
 10004f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 10004f4:	e3a0c090 	mov	ip, #144	; 0x90
 10004f8:	e20140fe 	and	r4, r1, #254	; 0xfe
 10004fc:	e3e0ea0f 	mvn	lr, #61440	; 0xf000
 1000500:	e5dd500f 	ldrb	r5, [sp, #15]
 1000504:	e20000ff 	and	r0, r0, #255	; 0xff
 1000508:	e50e4f93 	str	r4, [lr, #-3987]
 100050c:	e20110ff 	and	r1, r1, #255	; 0xff
 1000510:	e50ecfaf 	str	ip, [lr, #-4015]
 1000514:	e1a04002 	mov	r4, r2
 1000518:	e203c0ff 	and	ip, r3, #255	; 0xff
	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 100051c:	e51e3faf 	ldr	r3, [lr, #-4015]
 1000520:	e3130002 	tst	r3, #2	; 0x2
 1000524:	1afffffc 	bne	100051c <io_i2c0_byte_transfer+0x2c>
	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 1000528:	e51e3faf 	ldr	r3, [lr, #-4015]
 100052c:	e3130080 	tst	r3, #128	; 0x80
 1000530:	13e00000 	mvnne	r0, #0	; 0x0
 1000534:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
 1000538:	e35c0000 	cmp	ip, #0	; 0x0
 100053c:	0a000012 	beq	100058c <io_i2c0_byte_transfer+0x9c>
		adr_bytes--;
 1000540:	e24c3001 	sub	r3, ip, #1	; 0x1
 1000544:	e203c0ff 	and	ip, r3, #255	; 0xff
		if(adr_bytes == 1)
 1000548:	e35c0001 	cmp	ip, #1	; 0x1
			I2C0_DATA = data_adr >> 8;          // high byte
 100054c:	01a02424 	moveq	r2, r4, lsr #8
 1000550:	03e03a0f 	mvneq	r3, #61440	; 0xf000
		else
			I2C0_DATA = data_adr;               // low byte
 1000554:	13e03a0f 	mvnne	r3, #61440	; 0xf000
 1000558:	05032f93 	streq	r2, [r3, #-3987]
 100055c:	15034f93 	strne	r4, [r3, #-3987]
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 1000560:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 1000564:	e3a03010 	mov	r3, #16	; 0x10
 1000568:	e5023faf 	str	r3, [r2, #-4015]
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 100056c:	e5123faf 	ldr	r3, [r2, #-4015]
 1000570:	e3130002 	tst	r3, #2	; 0x2
 1000574:	1afffffc 	bne	100056c <io_i2c0_byte_transfer+0x7c>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 1000578:	e5123faf 	ldr	r3, [r2, #-4015]
 100057c:	e3130080 	tst	r3, #128	; 0x80
 1000580:	0affffec 	beq	1000538 <io_i2c0_byte_transfer+0x48>
 1000584:	e3e00001 	mvn	r0, #1	; 0x1
 1000588:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -2;
		}
	}

	if(rw == 'w'){
 100058c:	e3500077 	cmp	r0, #119	; 0x77
 1000590:	1a00000c 	bne	10005c8 <io_i2c0_byte_transfer+0xd8>
		// write adressed byte
		I2C0_DATA = data;                       // send data
 1000594:	e3e03a0f 	mvn	r3, #61440	; 0xf000
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 1000598:	e3a02050 	mov	r2, #80	; 0x50
 100059c:	e5035f93 	str	r5, [r3, #-3987]
 10005a0:	e5032faf 	str	r2, [r3, #-4015]
 10005a4:	e1a02003 	mov	r2, r3
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 10005a8:	e5123faf 	ldr	r3, [r2, #-4015]
 10005ac:	e3130002 	tst	r3, #2	; 0x2
 10005b0:	1afffffc 	bne	10005a8 <io_i2c0_byte_transfer+0xb8>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 10005b4:	e5123faf 	ldr	r3, [r2, #-4015]
 10005b8:	e2130080 	ands	r0, r3, #128	; 0x80
 10005bc:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -3;
		}
		else{
//			set_cmsr(_cmsr);
			return 0;
		}
	}

	if(rw == 'r'){
		// re-send control byte - this time with read-bit
		I2C0_DATA = id | 0x01;                  // device id and READ
		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
//			set_cmsr(_cmsr);
			return -3;
		}
		// read adressed byte
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		return I2C0_DATA;
 10005c0:	e3e00002 	mvn	r0, #2	; 0x2
	}

//	set_cmsr(_cmsr);
	return -4;
}
 10005c4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
 10005c8:	e3500072 	cmp	r0, #114	; 0x72
 10005cc:	13e00003 	mvnne	r0, #3	; 0x3
 10005d0:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
 10005d4:	e3813001 	orr	r3, r1, #1	; 0x1
 10005d8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 10005dc:	e3a01090 	mov	r1, #144	; 0x90
 10005e0:	e5023f93 	str	r3, [r2, #-3987]
 10005e4:	e5021faf 	str	r1, [r2, #-4015]
 10005e8:	e5123faf 	ldr	r3, [r2, #-4015]
 10005ec:	e3130002 	tst	r3, #2	; 0x2
 10005f0:	1afffffc 	bne	10005e8 <io_i2c0_byte_transfer+0xf8>
 10005f4:	e5123faf 	ldr	r3, [r2, #-4015]
 10005f8:	e3130080 	tst	r3, #128	; 0x80
 10005fc:	1affffef 	bne	10005c0 <io_i2c0_byte_transfer+0xd0>
 1000600:	e3a03068 	mov	r3, #104	; 0x68
 1000604:	e5023faf 	str	r3, [r2, #-4015]
 1000608:	e3e00a0f 	mvn	r0, #61440	; 0xf000
 100060c:	e5103faf 	ldr	r3, [r0, #-4015]
 1000610:	e3130002 	tst	r3, #2	; 0x2
 1000614:	1afffffc 	bne	100060c <io_i2c0_byte_transfer+0x11c>
 1000618:	e5100f93 	ldr	r0, [r0, #-3987]
 100061c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

01000620 <get_syscpreg>:




// ###########################################################################################################################
// System
// ###########################################################################################################################

// ******************************************************************************
// read system coprocessor register x
   unsigned long get_syscpreg(unsigned char index)
// ******************************************************************************
{
 1000620:	e20000ff 	and	r0, r0, #255	; 0xff
	unsigned long _cp_val;
	switch(index){
 1000624:	e350000f 	cmp	r0, #15	; 0xf
 1000628:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
 100062c:	ea00000f 	b	1000670 <.text+0x670>
 1000630:	010006f0 	streqd	r0, [r0, -r0]
 1000634:	010006e8 	smlatteq	r0, r8, r6, r0
 1000638:	010006e0 	smlatteq	r0, r0, r6, r0
 100063c:	010006d8 	ldreqd	r0, [r0, -r8]
 1000640:	010006d0 	ldreqd	r0, [r0, -r0]
 1000644:	010006c8 	smlabteq	r0, r8, r6, r0
 1000648:	010006c0 	smlabteq	r0, r0, r6, r0
 100064c:	010006b8 	streqh	r0, [r0, -r8]
 1000650:	010006b0 	streqh	r0, [r0, -r0]
 1000654:	010006a8 	smlatbeq	r0, r8, r6, r0
 1000658:	010006a0 	smlatbeq	r0, r0, r6, r0
 100065c:	01000698 	streqb	r0, [r0, -r8]
 1000660:	01000690 	streqb	r0, [r0, -r0]
 1000664:	01000688 	smlabbeq	r0, r8, r6, r0
 1000668:	01000680 	smlabbeq	r0, r0, r6, r0
 100066c:	01000678 	tsteq	r0, r8, ror r6
 1000670:	e3a00000 	mov	r0, #0	; 0x0
 1000674:	e1a0f00e 	mov	pc, lr
		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); break;
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); break;
 1000678:	ee1f0f1f 	mrc	15, 0, r0, cr15, cr15, {0}
		default:         _cp_val = 0; break;
	}
	return _cp_val;
}
 100067c:	e1a0f00e 	mov	pc, lr
 1000680:	ee1e0f1e 	mrc	15, 0, r0, cr14, cr14, {0}
 1000684:	e1a0f00e 	mov	pc, lr
 1000688:	ee1d0f1d 	mrc	15, 0, r0, cr13, cr13, {0}
 100068c:	e1a0f00e 	mov	pc, lr
 1000690:	ee1c0f1c 	mrc	15, 0, r0, cr12, cr12, {0}
 1000694:	e1a0f00e 	mov	pc, lr
 1000698:	ee1b0f1b 	mrc	15, 0, r0, cr11, cr11, {0}
 100069c:	e1a0f00e 	mov	pc, lr
 10006a0:	ee1a0f1a 	mrc	15, 0, r0, cr10, cr10, {0}
 10006a4:	e1a0f00e 	mov	pc, lr
 10006a8:	ee190f19 	mrc	15, 0, r0, cr9, cr9, {0}
 10006ac:	e1a0f00e 	mov	pc, lr
 10006b0:	ee180f18 	mrc	15, 0, r0, cr8, cr8, {0}
 10006b4:	e1a0f00e 	mov	pc, lr
 10006b8:	ee170f17 	mrc	15, 0, r0, cr7, cr7, {0}
 10006bc:	e1a0f00e 	mov	pc, lr
 10006c0:	ee160f16 	mrc	15, 0, r0, cr6, cr6, {0}
 10006c4:	e1a0f00e 	mov	pc, lr
 10006c8:	ee150f15 	mrc	15, 0, r0, cr5, cr5, {0}
 10006cc:	e1a0f00e 	mov	pc, lr
 10006d0:	ee140f14 	mrc	15, 0, r0, cr4, cr4, {0}
 10006d4:	e1a0f00e 	mov	pc, lr
 10006d8:	ee130f13 	mrc	15, 0, r0, cr3, cr3, {0}
 10006dc:	e1a0f00e 	mov	pc, lr
 10006e0:	ee120f12 	mrc	15, 0, r0, cr2, cr2, {0}
 10006e4:	e1a0f00e 	mov	pc, lr
 10006e8:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
 10006ec:	e1a0f00e 	mov	pc, lr
 10006f0:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
 10006f4:	e1a0f00e 	mov	pc, lr

010006f8 <set_syscpreg>:

// ******************************************************************************
// write system coprocessor register x
   void set_syscpreg(unsigned long _cp_val, unsigned char index)
// ******************************************************************************
{
 10006f8:	e20110ff 	and	r1, r1, #255	; 0xff
	switch(index){
 10006fc:	e2411006 	sub	r1, r1, #6	; 0x6
 1000700:	e3510007 	cmp	r1, #7	; 0x7
 1000704:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
 1000708:	ea000008 	b	1000730 <.text+0x730>
 100070c:	01000734 	tsteq	r0, r4, lsr r7
 1000710:	01000730 	tsteq	r0, r0, lsr r7
 1000714:	01000730 	tsteq	r0, r0, lsr r7
 1000718:	01000730 	tsteq	r0, r0, lsr r7
 100071c:	01000730 	tsteq	r0, r0, lsr r7
 1000720:	0100073c 	tsteq	r0, ip, lsr r7
 1000724:	01000744 	tsteq	r0, r4, asr #14
 1000728:	0100072c 	tsteq	r0, ip, lsr #14
//		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
 100072c:	ee0d0f1d 	mcr	15, 0, r0, cr13, cr13, {0}
 1000730:	e1a0f00e 	mov	pc, lr
 1000734:	ee060f16 	mcr	15, 0, r0, cr6, cr6, {0}
 1000738:	e1a0f00e 	mov	pc, lr
 100073c:	ee0b0f1b 	mcr	15, 0, r0, cr11, cr11, {0}
 1000740:	e1a0f00e 	mov	pc, lr
 1000744:	ee0c0f1c 	mcr	15, 0, r0, cr12, cr12, {0}
 1000748:	e1a0f00e 	mov	pc, lr

0100074c <io_enable_xint>:
//		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); break;
		default:         break;
	}
}
// ******************************************************************************
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 100074c:	e10f3000 	mrs	r3, CPSR
	return _cmsr;
}

// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 1000750:	e3c330c0 	bic	r3, r3, #192	; 0xc0
 1000754:	e129f003 	msr	CPSR_fc, r3
}

// ******************************************************************************
// Enable all external INTs
   void io_enable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
 1000758:	e1a0f00e 	mov	pc, lr

0100075c <io_disable_xint>:
 100075c:	e10f3000 	mrs	r3, CPSR
 1000760:	e38330c0 	orr	r3, r3, #192	; 0xc0
 1000764:	e129f003 	msr	CPSR_fc, r3

// ******************************************************************************
// Disable all global IBTs
   void io_disable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
 1000768:	e1a0f00e 	mov	pc, lr

0100076c <long_to_hex_string>:
   void long_to_hex_string(unsigned long data,    // max 32 bit data word
                           unsigned char *buffer, // buffer to store the string
						   unsigned char numbers) // number of places, max 8
// ############################################################################################
{
 100076c:	e92d4010 	stmdb	sp!, {r4, lr}
 1000770:	e20240ff 	and	r4, r2, #255	; 0xff
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
 1000774:	e3540008 	cmp	r4, #8	; 0x8
 1000778:	83a04008 	movhi	r4, #8	; 0x8
 100077c:	8a000001 	bhi	1000788 <long_to_hex_string+0x1c>
		numbers = 8;
	if(numbers < 1)
 1000780:	e3540000 	cmp	r4, #0	; 0x0
		numbers = 1;

	while(numbers > 0){
		// isolate one 4-bit value
		if(numbers > 1)
			temp_data = data >> ((numbers-1)*4);
		else
			temp_data = data;
		temp_data = temp_data & 0x0000000F;
		numbers--;

		// convert 4-bit value temp_data to char temp_char
		if(temp_data < 10)
			temp_char = '0' + temp_data;
		else
			temp_char = 'A' + temp_data - 10;

		// save character
		*buffer++ = temp_char;
	}

	*buffer++ = 0; // terminate string
}
 1000784:	03a04001 	moveq	r4, #1	; 0x1
 1000788:	e1a02001 	mov	r2, r1
 100078c:	e1a0e004 	mov	lr, r4
 1000790:	e1a0310e 	mov	r3, lr, lsl #2
 1000794:	e35e0001 	cmp	lr, #1	; 0x1
 1000798:	e2433004 	sub	r3, r3, #4	; 0x4
 100079c:	e1a0c000 	mov	ip, r0
 10007a0:	81a0c330 	movhi	ip, r0, lsr r3
 10007a4:	e24e3001 	sub	r3, lr, #1	; 0x1
 10007a8:	e20cc00f 	and	ip, ip, #15	; 0xf
 10007ac:	e203e0ff 	and	lr, r3, #255	; 0xff
 10007b0:	e35c0009 	cmp	ip, #9	; 0x9
 10007b4:	e28c3030 	add	r3, ip, #48	; 0x30
 10007b8:	828c3037 	addhi	r3, ip, #55	; 0x37
 10007bc:	e35e0000 	cmp	lr, #0	; 0x0
 10007c0:	e4c23001 	strb	r3, [r2], #1
 10007c4:	1afffff1 	bne	1000790 <long_to_hex_string+0x24>
 10007c8:	e2443001 	sub	r3, r4, #1	; 0x1
 10007cc:	e20330ff 	and	r3, r3, #255	; 0xff
 10007d0:	e0813003 	add	r3, r1, r3
 10007d4:	e5c3e001 	strb	lr, [r3, #1]
 10007d8:	e8bd8010 	ldmia	sp!, {r4, pc}

010007dc <get_adc>:

// ############################################################################################
// read external ADC value
   unsigned int get_adc(int adc_index) // adc 0..7
// ############################################################################################
{
 10007dc:	e92d4010 	stmdb	sp!, {r4, lr}
 10007e0:	e1a04000 	mov	r4, r0
	unsigned long temp;

	if ((adc_index < 0) || (adc_index > 7))
 10007e4:	e3540007 	cmp	r4, #7	; 0x7
		return 0;

	// config spi
	io_spi0_config(1,16); // auto assert cs, 16 bit transfer
 10007e8:	e3a01010 	mov	r1, #16	; 0x10
 10007ec:	e3a00001 	mov	r0, #1	; 0x1
 10007f0:	9a000001 	bls	10007fc <get_adc+0x20>
	io_spi0_enable(adc_cs);

	temp = adc_index * 2048;
	io_spi0_trans(0); // dummy read
	return (unsigned int)io_spi0_trans(temp);
}
 10007f4:	e3a00000 	mov	r0, #0	; 0x0
 10007f8:	e8bd8010 	ldmia	sp!, {r4, pc}
 10007fc:	ebffff06 	bl	100041c <io_spi0_config>
 1000800:	e3a00006 	mov	r0, #6	; 0x6
 1000804:	ebffff1e 	bl	1000484 <io_spi0_enable>
 1000808:	e3a00000 	mov	r0, #0	; 0x0
 100080c:	ebffff0e 	bl	100044c <io_spi0_trans>
 1000810:	e1a00584 	mov	r0, r4, lsl #11
 1000814:	e8bd4010 	ldmia	sp!, {r4, lr}
 1000818:	eaffff0b 	b	100044c <io_spi0_trans>

0100081c <delay>:

// ############################################################################################
// simple delay routine
   void delay(int time) // waits time*10000 clock ticks
// ############################################################################################
{
	time = time*2500*4;
 100081c:	e0603280 	rsb	r3, r0, r0, lsl #5
 1000820:	e0800103 	add	r0, r0, r3, lsl #2
 1000824:	e0800100 	add	r0, r0, r0, lsl #2
 1000828:	e1a00200 	mov	r0, r0, lsl #4
	while(time > 0){
 100082c:	e3500000 	cmp	r0, #0	; 0x0
 1000830:	d1a0f00e 	movle	pc, lr
		asm volatile ("NOP");
 1000834:	e1a00000 	nop			(mov r0,r0)
 1000838:	e2500001 	subs	r0, r0, #1	; 0x1
 100083c:	1afffffc 	bne	1000834 <delay+0x18>
 1000840:	e1a0f00e 	mov	pc, lr

01000844 <string_cmpc>:
		time--;
	}
}

// ############################################################################################
// String compare, buffered string with immediate const char string
   unsigned char string_cmpc(unsigned char *string1, const char *string2, unsigned char length)
// ############################################################################################
{
	while(length != 0){
 1000844:	e212c0ff 	ands	ip, r2, #255	; 0xff
 1000848:	0a00000b 	beq	100087c <string_cmpc+0x38>
		if(*string1++ != (unsigned char)*string2++)
 100084c:	e5d02000 	ldrb	r2, [r0]
 1000850:	e5d13000 	ldrb	r3, [r1]
 1000854:	e1520003 	cmp	r2, r3
 1000858:	0a000004 	beq	1000870 <string_cmpc+0x2c>
 100085c:	ea000008 	b	1000884 <string_cmpc+0x40>
 1000860:	e5f02001 	ldrb	r2, [r0, #1]!
 1000864:	e5f13001 	ldrb	r3, [r1, #1]!
 1000868:	e1520003 	cmp	r2, r3
 100086c:	1a000004 	bne	1000884 <string_cmpc+0x40>
			return(0); // missmatch
		length--;
 1000870:	e24c3001 	sub	r3, ip, #1	; 0x1
 1000874:	e213c0ff 	ands	ip, r3, #255	; 0xff
 1000878:	1afffff8 	bne	1000860 <string_cmpc+0x1c>
 100087c:	e3a00001 	mov	r0, #1	; 0x1
	}
	return(1); // match
}
 1000880:	e1a0f00e 	mov	pc, lr
 1000884:	e3a00000 	mov	r0, #0	; 0x0
 1000888:	e1a0f00e 	mov	pc, lr

0100088c <uart0_printf>:
// ############################################################################################
// Print text string via UART 0
   const char *uart0_printf(const char *string)
// ############################################################################################
{
 100088c:	e92d4010 	stmdb	sp!, {r4, lr}
 1000890:	e1a04000 	mov	r4, r0
	char ch;

	while ((ch = *string)){
 1000894:	e5d00000 	ldrb	r0, [r0]
 1000898:	e3500000 	cmp	r0, #0	; 0x0
 100089c:	1a000003 	bne	10008b0 <uart0_printf+0x24>
 10008a0:	ea000005 	b	10008bc <uart0_printf+0x30>
 10008a4:	e5f40001 	ldrb	r0, [r4, #1]!
 10008a8:	e3500000 	cmp	r0, #0	; 0x0
 10008ac:	0a000002 	beq	10008bc <uart0_printf+0x30>
		if (io_uart0_send_byte(ch)<=0)
 10008b0:	ebfffed2 	bl	1000400 <io_uart0_send_byte>
 10008b4:	e3500000 	cmp	r0, #0	; 0x0
 10008b8:	cafffff9 	bgt	10008a4 <uart0_printf+0x18>
			break;
		string++;
	}
	return string;
}
 10008bc:	e1a00004 	mov	r0, r4
 10008c0:	e8bd8010 	ldmia	sp!, {r4, pc}

010008c4 <uart0_scanf>:

// ############################################################################################
// Read text string via UART 0
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
 10008c4:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	int temp = 0;

	while(length > 0){
 10008c8:	e2514000 	subs	r4, r1, #0	; 0x0
 10008cc:	e1a05000 	mov	r5, r0
 10008d0:	e20260ff 	and	r6, r2, #255	; 0xff
 10008d4:	d8bd8070 	ldmleia	sp!, {r4, r5, r6, pc}
		temp = io_uart0_read_byte();
 10008d8:	ebfffec2 	bl	10003e8 <io_uart0_read_byte>
		if(temp != -1){
 10008dc:	e3700001 	cmn	r0, #1	; 0x1
			temp = (unsigned char)(temp & 0x000000FF);
 10008e0:	e20030ff 	and	r3, r0, #255	; 0xff
 10008e4:	0a000005 	beq	1000900 <uart0_scanf+0x3c>
			*buffer++ = temp;
			if(en_echo == 1)
 10008e8:	e3560001 	cmp	r6, #1	; 0x1
 10008ec:	e5c53000 	strb	r3, [r5]
				io_uart0_send_byte(temp); // echo
 10008f0:	e1a00003 	mov	r0, r3
 10008f4:	e2855001 	add	r5, r5, #1	; 0x1
 10008f8:	0a000003 	beq	100090c <uart0_scanf+0x48>
			length--;
 10008fc:	e2444001 	sub	r4, r4, #1	; 0x1
 1000900:	e3540000 	cmp	r4, #0	; 0x0
 1000904:	cafffff3 	bgt	10008d8 <uart0_scanf+0x14>
 1000908:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 100090c:	ebfffebb 	bl	1000400 <io_uart0_send_byte>
 1000910:	eafffff9 	b	10008fc <uart0_scanf+0x38>

01000914 <uart0_print_buffer>:
		}
	}
}

// ############################################################################################
// Print character buffer via UART 0
   void uart0_print_buffer(unsigned char *buffer, int size)
// ############################################################################################
{
 1000914:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	unsigned char char_buffer = 0;
	while(size > 0){
 1000918:	e2514000 	subs	r4, r1, #0	; 0x0
 100091c:	e1a05000 	mov	r5, r0
 1000920:	d8bd8030 	ldmleia	sp!, {r4, r5, pc}
		char_buffer = *buffer++;
		io_uart0_send_byte((int)char_buffer);
 1000924:	e4d50001 	ldrb	r0, [r5], #1
 1000928:	ebfffeb4 	bl	1000400 <io_uart0_send_byte>
 100092c:	e2544001 	subs	r4, r4, #1	; 0x1
 1000930:	1afffffb 	bne	1000924 <uart0_print_buffer+0x10>
 1000934:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

01000938 <timer0_isr>:


/* ---- IRQ: Timer ISR ---- */
void __attribute__ ((interrupt("IRQ"))) timer0_isr(void)
{
 1000938:	e24ee004 	sub	lr, lr, #4	; 0x4
 100093c:	e92d500f 	stmdb	sp!, {r0, r1, r2, r3, ip, lr}
	// toggle status led
	set_syscpreg((get_syscpreg(SYS_IO) ^ 0x01), SYS_IO);
 1000940:	e3a0000d 	mov	r0, #13	; 0xd
 1000944:	ebffff35 	bl	1000620 <get_syscpreg>
 1000948:	e3a0100d 	mov	r1, #13	; 0xd
 100094c:	e2200001 	eor	r0, r0, #1	; 0x1
 1000950:	ebffff68 	bl	10006f8 <set_syscpreg>

	// acknowledge interrupt
	VICVectAddr = 0;
 1000954:	e3a02000 	mov	r2, #0	; 0x0
 1000958:	e3e03000 	mvn	r3, #0	; 0x0
 100095c:	e5032fcf 	str	r2, [r3, #-4047]
}
 1000960:	e8fd900f 	ldmia	sp!, {r0, r1, r2, r3, ip, pc}^

01000964 <main>:


/* ---- Main function ---- */
int main(void)
{
	int temp;

	// timer init
	STME0_CNT  = 0;
	STME0_VAL  = 50000000; // threshold value for 1s ticks
 1000964:	e3a027be 	mov	r2, #49807360	; 0x2f80000
 1000968:	e2822a2f 	add	r2, r2, #192512	; 0x2f000
 100096c:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 1000970:	e2822080 	add	r2, r2, #128	; 0x80
 1000974:	e3a03000 	mov	r3, #0	; 0x0
 1000978:	e5013fdf 	str	r3, [r1, #-4063]
 100097c:	e5012fdb 	str	r2, [r1, #-4059]
	STME0_CONF = (1<<2) | (1<<1) | (1<<0); // interrupt en, auto reset, timer enable
	VICVectAddr0 = (unsigned long)timer0_isr;
 1000980:	e59f205c 	ldr	r2, [pc, #92]	; 10009e4 <.text+0x9e4>
 1000984:	e3e00000 	mvn	r0, #0	; 0x0
 1000988:	e2833007 	add	r3, r3, #7	; 0x7
 100098c:	e5013fd7 	str	r3, [r1, #-4055]
 1000990:	e5002fbf 	str	r2, [r0, #-4031]
	VICVectCntl0 = (1<<5) | 0; // enable and channel select = 0 (timer0)
 1000994:	e2833019 	add	r3, r3, #25	; 0x19
	VICIntEnable = (1<<0); // enable channel 0 (timer0)
 1000998:	e3a02001 	mov	r2, #1	; 0x1
 100099c:	e5003f7f 	str	r3, [r0, #-3967]
 10009a0:	e52de004 	str	lr, [sp, #-4]!
 10009a4:	e5002fef 	str	r2, [r0, #-4079]
	io_enable_xint(); // enable IRQ
 10009a8:	ebffff67 	bl	100074c <io_enable_xint>

	// Intro
	uart0_printf("\r\n\r\nSTORM SoC Basic Configuration\r\n");
 10009ac:	e59f0034 	ldr	r0, [pc, #52]	; 10009e8 <.text+0x9e8>
 10009b0:	ebffffb5 	bl	100088c <uart0_printf>
	uart0_printf("Demo program\r\n\r\n");
 10009b4:	e59f0030 	ldr	r0, [pc, #48]	; 10009ec <.text+0x9ec>
 10009b8:	ebffffb3 	bl	100088c <uart0_printf>

	uart0_printf("Press any key!\r\n");
 10009bc:	e59f002c 	ldr	r0, [pc, #44]	; 10009f0 <.text+0x9f0>
 10009c0:	ebffffb1 	bl	100088c <uart0_printf>

	// echo received char
	while(1){
		temp = io_uart0_read_byte();
 10009c4:	ebfffe87 	bl	10003e8 <io_uart0_read_byte>
		if (temp != -1)
 10009c8:	e3700001 	cmn	r0, #1	; 0x1
 10009cc:	0afffffc 	beq	10009c4 <main+0x60>
			io_uart0_send_byte(temp);
 10009d0:	ebfffe8a 	bl	1000400 <io_uart0_send_byte>
 10009d4:	ebfffe83 	bl	10003e8 <io_uart0_read_byte>
 10009d8:	e3700001 	cmn	r0, #1	; 0x1
 10009dc:	1afffffb 	bne	10009d0 <main+0x6c>
 10009e0:	eafffff7 	b	10009c4 <main+0x60>
 10009e4:	01000938 	tsteq	r0, r8, lsr r9
 10009e8:	010009f4 	streqd	r0, [r0, -r4]
 10009ec:	01000a18 	tsteq	r0, r8, lsl sl
 10009f0:	01000a2c 	tsteq	r0, ip, lsr #20
 10009f4:	0d0a0d0a 	stceq	13, cr0, [sl, #-40]
 10009f8:	53544f52 	cmppl	r4, #328	; 0x148
 10009fc:	4d20536f 	stcmi	3, cr5, [r0, #-444]!
 1000a00:	43204261 	teqmi	r0, #268435462	; 0x10000006
 1000a04:	73696320 	cmnvc	r9, #-2147483648	; 0x80000000
 1000a08:	436f6e66 	cmnmi	pc, #1632	; 0x660
 1000a0c:	69677572 	stmvsdb	r7!, {r1, r4, r5, r6, r8, sl, ip, sp, lr}^
 1000a10:	6174696f 	cmnvs	r4, pc, ror #18
 1000a14:	6e0d0a00 	fmacsvs	s0, s26, s0
 1000a18:	44656d6f 	strmibt	r6, [r5], #-3439
 1000a1c:	2070726f 	rsbcss	r7, r0, pc, ror #4
 1000a20:	6772616d 	ldrvsb	r6, [r2, -sp, ror #2]!
 1000a24:	0d0a0d0a 	stceq	13, cr0, [sl, #-40]
 1000a28:	00000000 	andeq	r0, r0, r0
 1000a2c:	50726573 	rsbpls	r6, r2, r3, ror r5
 1000a30:	7320616e 	teqvc	r0, #-2147483621	; 0x8000001b
 1000a34:	79206b65 	stmvcdb	r0!, {r0, r2, r5, r6, r8, r9, fp, sp, lr}
 1000a38:	79210d0a 	stmvcdb	r1!, {r1, r3, r8, sl, fp}
 1000a3c:	00000000 	andeq	r0, r0, r0
