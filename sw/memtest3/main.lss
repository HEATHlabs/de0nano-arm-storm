
main.elf:     file format elf32-bigarm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000ddc  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .stack        00004000  00000e00  00000e00  00008ddc  2**0
                  ALLOC
  2 .comment      0000001b  00000000  00000000  00008ddc  2**0
                  CONTENTS, READONLY
  3 .debug_aranges 00000040  00000000  00000000  00008df8  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000025d  00000000  00000000  00008e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000008b4  00000000  00000000  00009095  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000268  00000000  00000000  00009949  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000363  00000000  00000000  00009bb1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000250  00000000  00000000  00009f14  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000032d  00000000  00000000  0000a164  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000832  00000000  00000000  0000a491  2**0
                  CONTENTS, READONLY, DEBUGGING
Disassembly of section .text:

00000000 <_boot>:

// Runtime Interrupt Vectors
// -------------------------
Vectors:
        b     _start                    // reset - _start
   0:	ea000012 	b	50 <_mainCRTStartup>
        b     und_handler               // undefined - _undf
   4:	ea000062 	b	194 <und_handler>
        b     swi_handler               // SWI - _swi
   8:	ea000055 	b	164 <swi_handler>
        b     iab_handler               // program abort - _pabt
   c:	ea000048 	b	134 <iab_handler>
        b     iab_handler               // data abort - _dabt
  10:	ea000047 	b	134 <iab_handler>
        nop                             // reserved
  14:	e1a00000 	nop			(mov r0,r0)
        ldr   pc,[pc,#-0xFF0]           // IRQ - read the VIC
  18:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff030 <_end+0xffffa230>
        ldr   pc,[pc,#-0xFF0]           // FIQ - read the VIC
  1c:	e51ffff0 	ldr	pc, [pc, #-4080]	; fffff034 <_end+0xffffa234>

00000020 <_undf>:
  20:	00000038 	andeq	r0, r0, r8, lsr r0

00000024 <_swi>:
  24:	0000003c 	andeq	r0, r0, ip, lsr r0

00000028 <_pabt>:
  28:	00000040 	andeq	r0, r0, r0, asr #32

0000002c <_dabt>:
  2c:	00000044 	andeq	r0, r0, r4, asr #32

00000030 <_irq>:
  30:	00000048 	andeq	r0, r0, r8, asr #32

00000034 <_fiq>:
  34:	0000004c 	andeq	r0, r0, ip, asr #32

00000038 <__undf>:

#if 0
// Use this group for production
_undf:  .word _reset                    // undefined - _reset
_swi:   .word _reset                    // SWI - _reset
_pabt:  .word _reset                    // program abort - _reset
_dabt:  .word _reset                    // data abort - _reset
_irq:   .word _reset                    // IRQ - _reset
_fiq:   .word _reset                    // FIQ - _reset

#else
// Use this group for development
_undf:  .word __undf                    // undefined
_swi:   .word __swi                     // SWI
_pabt:  .word __pabt                    // program abort
_dabt:  .word __dabt                    // data abort
_irq:   .word __irq                     // IRQ
_fiq:   .word __fiq                     // FIQ

__undf: b     .                         // undefined
  38:	eafffffe 	b	38 <__undf>

0000003c <__swi>:
__swi:  b     .                         // SWI
  3c:	eafffffe 	b	3c <__swi>

00000040 <__pabt>:
__pabt: b     .                         // program abort
  40:	eafffffe 	b	40 <FIQ_BIT>

00000044 <__dabt>:
__dabt: b     .                         // data abort
  44:	eafffffe 	b	44 <__dabt>

00000048 <__irq>:
__irq:  b     .                         // IRQ
  48:	eafffffe 	b	48 <__irq>

0000004c <__fiq>:
__fiq:  b     .                         // FIQ
  4c:	eafffffe 	b	4c <__fiq>

00000050 <_mainCRTStartup>:
#endif
        .size _boot, . - _boot
        .endfunc


// Setup the operating mode & stack.
// ---------------------------------
        .global _start, start, _mainCRTStartup
        .func   _start

_start:
start:
_mainCRTStartup:

// Initialize Interrupt System
// - Set stack location for each mode
// - Leave in System Mode with Interrupts Disabled
// -----------------------------------------------
        ldr   r0,=_stack                    // Calc stack base
  50:	e59f0228 	ldr	r0, [pc, #552]	; 280 <.text+0x280>
		mrs   r1,CPSR
  54:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  58:	e3c1107f 	bic	r1, r1, #127	; 0x7f
		orr   r1,r1,#MODE_UND|IRQ_BIT|FIQ_BIT  // Change to Undefined Instruction mode
  5c:	e38110db 	orr	r1, r1, #219	; 0xdb
        msr   CPSR,r1
  60:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  64:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#UND_STACK_SIZE         // Calc stack base
  68:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  6c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  70:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_ABT|IRQ_BIT|FIQ_BIT  // Change to Abort Mode
  74:	e38110d7 	orr	r1, r1, #215	; 0xd7
        msr   CPSR,r1
  78:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  7c:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#ABT_STACK_SIZE         // Calc stack base
  80:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  84:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  88:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_FIQ|IRQ_BIT|FIQ_BIT  // Change to FIQ Mode
  8c:	e38110d1 	orr	r1, r1, #209	; 0xd1
        msr   CPSR,r1
  90:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  94:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#FIQ_STACK_SIZE         // Calc stack base
  98:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  9c:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  a0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_IRQ|IRQ_BIT|FIQ_BIT  // Change to IRQ Mode
  a4:	e38110d2 	orr	r1, r1, #210	; 0xd2
        msr   CPSR,r1
  a8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  ac:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#IRQ_STACK_SIZE         // Calc stack base
  b0:	e2400080 	sub	r0, r0, #128	; 0x80
		mrs   r1,CPSR
  b4:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  b8:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SVC|IRQ_BIT|FIQ_BIT  // Change to Supervisor Mode
  bc:	e38110d3 	orr	r1, r1, #211	; 0xd3
        msr   CPSR,r1
  c0:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  c4:	e1a0d000 	mov	sp, r0

        sub   r0,r0,#SVC_STACK_SIZE         // Calc stack base
  c8:	e2400004 	sub	r0, r0, #4	; 0x4
		mrs   r1,CPSR
  cc:	e10f1000 	mrs	r1, CPSR
		bic   r1,r1,#0x7F
  d0:	e3c1107f 	bic	r1, r1, #127	; 0x7f
        orr   r1,r1,#MODE_SYS|IRQ_BIT|FIQ_BIT  // Change to System Mode
  d4:	e38110df 	orr	r1, r1, #223	; 0xdf
        msr   CPSR,r1
  d8:	e129f001 	msr	CPSR_fc, r1
        mov   sp,r0                         // Store stack base
  dc:	e1a0d000 	mov	sp, r0

// Copy initialized data to its execution address in RAM
// -> not necessary, bootloader can be directly ecxecuted from ROM
// -----------------------------------------------------
//#ifdef ROM_RUN
//        ldr   r1,=_etext                // -> ROM data start
//        ldr   r2,=_data                 // -> data start
//        ldr   r3,=_edata                // -> end of data
//1:      cmp   r2,r3                     // check if data to move
//        ldrlo r0,[r1],#4                // copy it
//        strlo r0,[r2],#4
//        blo   1b                        // loop until done
//#endif

// Clear .bss
// Hell no!
// ----------
//        mov   r0,#0                     // get a zero
//        ldr   r1,=__bss_start           // -> bss start
//        ldr   r2,=__bss_end__           // -> bss end
//2:      cmp   r1,r2                     // check if data to clear
//        strlo r0,[r1],#4                // clear 4 bytes
//        blo   2b                        // loop until done

// Call main program: main(0)
// --------------------------
        mov   r0,#0                     // no arguments (argc = 0)
  e0:	e3a00000 	mov	r0, #0	; 0x0
        mov   r1,r0
  e4:	e1a01000 	mov	r1, r0
        mov   r2,r0
  e8:	e1a02000 	mov	r2, r0
        mov   fp,r0                     // null frame pointer
  ec:	e1a0b000 	mov	fp, r0
        mov   r7,r0                     // null frame pointer for thumb
  f0:	e1a07000 	mov	r7, r0
        ldr   r10,=main
  f4:	e59fa188 	ldr	sl, [pc, #392]	; 284 <.text+0x284>
        mov   lr,pc
  f8:	e1a0e00f 	mov	lr, pc
        bx    r10                       // enter main()
  fc:	e12fff1a 	bx	sl

00000100 <_reset>:

        .size   _start, . - _start
        .endfunc

        .global _reset, reset, exit, abort
        .func   _reset
_reset:
reset:
exit:
abort:

        b     .                         // loop until reset
 100:	eafffffe 	b	100 <_reset>

00000104 <dab_handler>:

// Data Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
dab_handler:
		mov   r13, lr
 104:	e1a0d00e 	mov	sp, lr
		mov   r4, #16
 108:	e3a04010 	mov	r4, #16	; 0x10
		mcr   p15, 0, r4, c13, c13, 0
 10c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 110:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 114:	eb000051 	bl	260 <uart0_send_byte>
		mov   r4, #'D'
 118:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 11c:	eb00004f 	bl	260 <uart0_send_byte>
		mov   r4, #'A'
 120:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 124:	eb00004d 	bl	260 <uart0_send_byte>
		mov   r4, #'B'
 128:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 12c:	eb00004b 	bl	260 <uart0_send_byte>
		b     isr_handler
 130:	ea000022 	b	1c0 <isr_handler>

00000134 <iab_handler>:

// Instruction Fetch Abort Interrupt Handler
// -------------------------------------------------------------------
iab_handler:
		mov   r13, lr
 134:	e1a0d00e 	mov	sp, lr
		mov   r4, #32
 138:	e3a04020 	mov	r4, #32	; 0x20
		mcr   p15, 0, r4, c13, c13, 0
 13c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 140:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 144:	eb000045 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 148:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 14c:	eb000043 	bl	260 <uart0_send_byte>
		mov   r4, #'A'
 150:	e3a04041 	mov	r4, #65	; 0x41
		bl    uart0_send_byte
 154:	eb000041 	bl	260 <uart0_send_byte>
		mov   r4, #'B'
 158:	e3a04042 	mov	r4, #66	; 0x42
		bl    uart0_send_byte
 15c:	eb00003f 	bl	260 <uart0_send_byte>
		b     isr_handler
 160:	ea000016 	b	1c0 <isr_handler>

00000164 <swi_handler>:

// Software Interrupt Handler
// -------------------------------------------------------------------
swi_handler:
		mov   r13, lr
 164:	e1a0d00e 	mov	sp, lr
		mov   r4, #64
 168:	e3a04040 	mov	r4, #64	; 0x40
		mcr   p15, 0, r4, c13, c13, 0
 16c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 170:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 174:	eb000039 	bl	260 <uart0_send_byte>
		mov   r4, #'S'
 178:	e3a04053 	mov	r4, #83	; 0x53
		bl    uart0_send_byte
 17c:	eb000037 	bl	260 <uart0_send_byte>
		mov   r4, #'W'
 180:	e3a04057 	mov	r4, #87	; 0x57
		bl    uart0_send_byte
 184:	eb000035 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 188:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 18c:	eb000033 	bl	260 <uart0_send_byte>
		b     isr_handler
 190:	ea00000a 	b	1c0 <isr_handler>

00000194 <und_handler>:

// Undefined Instruction Interrupt Handler
// -------------------------------------------------------------------
und_handler:
		mov   r13, lr
 194:	e1a0d00e 	mov	sp, lr
		mov   r4, #128
 198:	e3a04080 	mov	r4, #128	; 0x80
		mcr   p15, 0, r4, c13, c13, 0
 19c:	ee0d4f1d 	mcr	15, 0, r4, cr13, cr13, {0}
		mov   r4, #'<'
 1a0:	e3a0403c 	mov	r4, #60	; 0x3c
		bl    uart0_send_byte
 1a4:	eb00002d 	bl	260 <uart0_send_byte>
		mov   r4, #'U'
 1a8:	e3a04055 	mov	r4, #85	; 0x55
		bl    uart0_send_byte
 1ac:	eb00002b 	bl	260 <uart0_send_byte>
		mov   r4, #'N'
 1b0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 1b4:	eb000029 	bl	260 <uart0_send_byte>
		mov   r4, #'D'
 1b8:	e3a04044 	mov	r4, #68	; 0x44
		bl    uart0_send_byte
 1bc:	eb000027 	bl	260 <uart0_send_byte>

000001c0 <isr_handler>:

// Interrupt Handler
// -------------------------------------------------------------------
isr_handler:
		mov   r4, #'-'
 1c0:	e3a0402d 	mov	r4, #45	; 0x2d
		bl    uart0_send_byte
 1c4:	eb000025 	bl	260 <uart0_send_byte>
		mov   r4, #'I'
 1c8:	e3a04049 	mov	r4, #73	; 0x49
		bl    uart0_send_byte
 1cc:	eb000023 	bl	260 <uart0_send_byte>
		mov   r4, #'N'
 1d0:	e3a0404e 	mov	r4, #78	; 0x4e
		bl    uart0_send_byte
 1d4:	eb000021 	bl	260 <uart0_send_byte>
		mov   r4, #'T'
 1d8:	e3a04054 	mov	r4, #84	; 0x54
		bl    uart0_send_byte
 1dc:	eb00001f 	bl	260 <uart0_send_byte>
		mov   r4, #' '
 1e0:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
 1e4:	eb00001d 	bl	260 <uart0_send_byte>
		mov   r4, #'@'
 1e8:	e3a04040 	mov	r4, #64	; 0x40
		bl    uart0_send_byte
 1ec:	eb00001b 	bl	260 <uart0_send_byte>

		sub   r7, r13, #4
 1f0:	e24d7004 	sub	r7, sp, #4	; 0x4
		bl    uart0_print_hex
 1f4:	eb00000a 	bl	224 <uart0_print_hex>

		mov   r4, #' '
 1f8:	e3a04020 	mov	r4, #32	; 0x20
		bl    uart0_send_byte
 1fc:	eb000017 	bl	260 <uart0_send_byte>
		mov   r4, #'['		
 200:	e3a0405b 	mov	r4, #91	; 0x5b
		bl    uart0_send_byte
 204:	eb000015 	bl	260 <uart0_send_byte>

		mrc   p15,0,r7, c9, c9
 208:	ee197f19 	mrc	15, 0, r7, cr9, cr9, {0}
		bl    uart0_print_hex
 20c:	eb000004 	bl	224 <uart0_print_hex>

		mov   r4, #']'
 210:	e3a0405d 	mov	r4, #93	; 0x5d
		bl    uart0_send_byte
 214:	eb000011 	bl	260 <uart0_send_byte>
		mov   r4, #'>'
 218:	e3a0403e 	mov	r4, #62	; 0x3e
		bl    uart0_send_byte
 21c:	eb00000f 	bl	260 <uart0_send_byte>
		b .
 220:	eafffffe 	b	220 <isr_handler+0x60>

00000224 <uart0_print_hex>:


// Send 32-bit HEX value via UART0
// -------------------------------------------------------------------
uart0_print_hex:
		mov   r9, lr // save link register
 224:	e1a0900e 	mov	r9, lr
		mov   r8, #32
 228:	e3a08020 	mov	r8, #32	; 0x20

0000022c <uart0_print_hex_loop>:

uart0_print_hex_loop:
		cmp   r8, #0
 22c:	e3580000 	cmp	r8, #0	; 0x0
		moveq pc, r9
 230:	01a0f009 	moveq	pc, r9

		sub   r8, r8, #4
 234:	e2488004 	sub	r8, r8, #4	; 0x4
		mov   r6, r7, lsr r8 // isolate 4-bit value
 238:	e1a06837 	mov	r6, r7, lsr r8
		and   r6, r6, #0x0F
 23c:	e206600f 	and	r6, r6, #15	; 0xf

		cmp   r6, #9
 240:	e3560009 	cmp	r6, #9	; 0x9
		bgt   adapt_char
 244:	ca000001 	bgt	250 <adapt_char>
		add   r4, r6, #'0'
 248:	e2864030 	add	r4, r6, #48	; 0x30

		b     uart0_print_hex_char
 24c:	ea000001 	b	258 <uart0_print_hex_char>

00000250 <adapt_char>:
adapt_char:
		sub   r6, r6, #10
 250:	e246600a 	sub	r6, r6, #10	; 0xa
		add   r4, r6, #'A'
 254:	e2864041 	add	r4, r6, #65	; 0x41

00000258 <uart0_print_hex_char>:

uart0_print_hex_char:
		bl    uart0_send_byte
 258:	eb000000 	bl	260 <uart0_send_byte>
		b     uart0_print_hex_loop
 25c:	eafffff2 	b	22c <uart0_print_hex_loop>

00000260 <uart0_send_byte>:


// Send one char via UART0
// -------------------------------------------------------------------
uart0_send_byte:
		ldr   r0, =(0xFFFF001C)
 260:	e59f0020 	ldr	r0, [pc, #32]	; 288 <.text+0x288>
		ldr   r0, [r0]
 264:	e5900000 	ldr	r0, [r0]
		and   r0, r0, #0x01
 268:	e2000001 	and	r0, r0, #1	; 0x1
		cmp   r0, #0
 26c:	e3500000 	cmp	r0, #0	; 0x0
		beq   uart0_send_byte
 270:	0afffffa 	beq	260 <uart0_send_byte>
		ldr   r0, =(0xFFFF0018)
 274:	e59f0010 	ldr	r0, [pc, #16]	; 28c <.text+0x28c>
		str   r4, [r0]
 278:	e5804000 	str	r4, [r0]
		mov   pc, lr
 27c:	e1a0f00e 	mov	pc, lr
 280:	00004e00 	andeq	r4, r0, r0, lsl #28
 284:	00000ad0 	ldreqd	r0, [r0], -r0
 288:	ffff001c 	undefined instruction 0xffff001c
 28c:	ffff0018 	undefined instruction 0xffff0018

00000290 <io_read_gpio0_pin>:
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN & (1<<pin);
 290:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 294:	e5131ffb 	ldr	r1, [r3, #-4091]
 298:	e20020ff 	and	r2, r0, #255	; 0xff
	
//	set_cmsr(_cmsr);
	return temp;
}
 29c:	e3a00001 	mov	r0, #1	; 0x1
 2a0:	e0010210 	and	r0, r1, r0, lsl r2
 2a4:	e12fff1e 	bx	lr

000002a8 <io_read_gpio0_port>:

// ******************************************************************************
// Read general purpose IO port
   unsigned long io_read_gpio0_port(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		unsigned long temp = GPIO0_IN;
 2a8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 2ac:	e5130ffb 	ldr	r0, [r3, #-4091]

//	set_cmsr(_cmsr);
	return temp;
}
 2b0:	e12fff1e 	bx	lr

000002b4 <io_set_gpio0_pin>:

// ******************************************************************************
// Set general purpose IO port
   void io_set_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT | (1<<pin);
 2b4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 2b8:	e5113fff 	ldr	r3, [r1, #-4095]
 2bc:	e20000ff 	and	r0, r0, #255	; 0xff
 2c0:	e3a02001 	mov	r2, #1	; 0x1
 2c4:	e1833012 	orr	r3, r3, r2, lsl r0
 2c8:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 2cc:	e12fff1e 	bx	lr

000002d0 <io_clr_gpio0_pin>:

// ******************************************************************************
// Clear general purpose IO port
   void io_clr_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
 2d0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT & ~(1<<pin);
 2d4:	e3a02001 	mov	r2, #1	; 0x1
 2d8:	e1a02012 	mov	r2, r2, lsl r0
 2dc:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 2e0:	e5113fff 	ldr	r3, [r1, #-4095]
 2e4:	e1e02002 	mvn	r2, r2
 2e8:	e0033002 	and	r3, r3, r2
 2ec:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 2f0:	e12fff1e 	bx	lr

000002f4 <io_toggle_gpio0_pin>:
// ******************************************************************************
// Set general purpose IO port
   void io_toggle_gpio0_pin(unsigned char pin)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = GPIO0_OUT ^ (1<<pin);
 2f4:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 2f8:	e5113fff 	ldr	r3, [r1, #-4095]
 2fc:	e20000ff 	and	r0, r0, #255	; 0xff
 300:	e3a02001 	mov	r2, #1	; 0x1
 304:	e0233012 	eor	r3, r3, r2, lsl r0
 308:	e5013fff 	str	r3, [r1, #-4095]

//	set_cmsr(_cmsr);
}
 30c:	e12fff1e 	bx	lr

00000310 <io_set_gpio0_port>:

// ******************************************************************************
// Clear general purpose IO port
   void io_set_gpio0_port(unsigned long value)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		GPIO0_OUT = value;
 310:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 314:	e5030fff 	str	r0, [r3, #-4095]

//	set_cmsr(_cmsr);
}
 318:	e12fff1e 	bx	lr

0000031c <io_set_pwm>:



// ###########################################################################################################################
// Pulse-Width-Modulation Controller
// ###########################################################################################################################

// ******************************************************************************
// Set pwm value
   void io_set_pwm(unsigned char port, unsigned char data)
// ******************************************************************************
{
 31c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 320:	e3500007 	cmp	r0, #7	; 0x7
 324:	e92d4010 	stmdb	sp!, {r4, lr}
 328:	e3a0c000 	mov	ip, #0	; 0x0
 32c:	e3e0e0ff 	mvn	lr, #255	; 0xff
 330:	e20110ff 	and	r1, r1, #255	; 0xff
 334:	8a000011 	bhi	380 <io_set_pwm+0x64>
		port = 0;

	if(port < 4){
		temp = PWM0_CONF0; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
		PWM0_CONF0 = temp;
	}
	else{
		port = port-4;
		temp = PWM0_CONF1; // get working copy
		temp = temp & ~(0xFF << (port*8)); // clear old value
 338:	e2403004 	sub	r3, r0, #4	; 0x4
 33c:	e20330ff 	and	r3, r3, #255	; 0xff
 340:	e3500003 	cmp	r0, #3	; 0x3
 344:	e1a0e183 	mov	lr, r3, lsl #3
 348:	e3e04a0f 	mvn	r4, #61440	; 0xf000
 34c:	e1a0c180 	mov	ip, r0, lsl #3
 350:	9a000007 	bls	374 <io_set_pwm+0x58>
 354:	e3a030ff 	mov	r3, #255	; 0xff
 358:	e1a03e13 	mov	r3, r3, lsl lr
 35c:	e5142f8b 	ldr	r2, [r4, #-3979]
 360:	e1e03003 	mvn	r3, r3
 364:	e0022003 	and	r2, r2, r3
		temp = temp | (unsigned long)(data << (port*8)); // insert new value
 368:	e1822e11 	orr	r2, r2, r1, lsl lr
		PWM0_CONF1 = temp;
 36c:	e5042f8b 	str	r2, [r4, #-3979]
 370:	e8bd8010 	ldmia	sp!, {r4, pc}
 374:	e3a030ff 	mov	r3, #255	; 0xff
 378:	e1a03c13 	mov	r3, r3, lsl ip
 37c:	e1e0e003 	mvn	lr, r3
 380:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 384:	e5123f8f 	ldr	r3, [r2, #-3983]
 388:	e003300e 	and	r3, r3, lr
 38c:	e1833c11 	orr	r3, r3, r1, lsl ip
 390:	e5023f8f 	str	r3, [r2, #-3983]
 394:	e8bd8010 	ldmia	sp!, {r4, pc}

00000398 <io_get_pwm>:
	}
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Set pwm value
   unsigned char io_get_pwm(unsigned char port)
// ******************************************************************************
{
 398:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	unsigned long temp = 0;

	// value adjustment
	if(port > 7)
 39c:	e3500007 	cmp	r0, #7	; 0x7
 3a0:	e3a02000 	mov	r2, #0	; 0x0
 3a4:	8a00000a 	bhi	3d4 <io_get_pwm+0x3c>
		port = 0;

	if(port < 4)
		temp = PWM0_CONF0; // get config register
	else{
		port = port-4;
		temp = PWM0_CONF1; // get config register
 3a8:	e2403004 	sub	r3, r0, #4	; 0x4
 3ac:	e3500003 	cmp	r0, #3	; 0x3
 3b0:	e20320ff 	and	r2, r3, #255	; 0xff
 3b4:	9a000005 	bls	3d0 <io_get_pwm+0x38>
 3b8:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 3bc:	e5130f8b 	ldr	r0, [r3, #-3979]
 3c0:	e1a02182 	mov	r2, r2, lsl #3
 3c4:	e1a00230 	mov	r0, r0, lsr r2
 3c8:	e20000ff 	and	r0, r0, #255	; 0xff
	}

	temp = temp >> (port*8); // only keep designated byte

//	set_cmsr(_cmsr);
	return (unsigned char)temp;
}
 3cc:	e12fff1e 	bx	lr
 3d0:	e1a02180 	mov	r2, r0, lsl #3
 3d4:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 3d8:	e5130f8f 	ldr	r0, [r3, #-3983]
 3dc:	e1a00230 	mov	r0, r0, lsr r2
 3e0:	e20000ff 	and	r0, r0, #255	; 0xff
 3e4:	e12fff1e 	bx	lr

000003e8 <io_uart0_read_byte>:



// ###########################################################################################################################
// General Purpose UART "miniUART" (UART_0)
// ###########################################################################################################################

// ******************************************************************************
// Read one byte via UART 0
   int io_uart0_read_byte(void)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	int temp;
	if ((UART0_SREG & (1<<CUART_RXD)) != 0) // byte available?
 3e8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 3ec:	e5123fe3 	ldr	r3, [r2, #-4067]
 3f0:	e3130002 	tst	r3, #2	; 0x2
 3f4:	e3e00000 	mvn	r0, #0	; 0x0
		temp = UART0_DATA;
 3f8:	15120fe7 	ldrne	r0, [r2, #-4071]
	else
		temp = -1;

//	set_cmsr(_cmsr);
	return temp;
}
 3fc:	e12fff1e 	bx	lr

00000400 <io_uart0_send_byte>:

// ******************************************************************************
// Write one byte via UART 0
   int io_uart0_send_byte(int ch)
// ******************************************************************************
{
 400:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	while((UART0_SREG & (1<<CUART_TXB)) == 0); // uart busy?
 404:	e5123fe3 	ldr	r3, [r2, #-4067]
 408:	e3130001 	tst	r3, #1	; 0x1
 40c:	0afffffc 	beq	404 <io_uart0_send_byte+0x4>
	UART0_DATA = (ch & 0x000000FF);
 410:	e20030ff 	and	r3, r0, #255	; 0xff
 414:	e5023fe7 	str	r3, [r2, #-4071]

//	set_cmsr(_cmsr);
	return ch;
}
 418:	e12fff1e 	bx	lr

0000041c <io_spi0_config>:



// ###########################################################################################################################
// Serial Peripherial Interface (SPI_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0
   void io_spi0_config(unsigned char auto_cs, unsigned long data_size)
// ******************************************************************************
{
 41c:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
	// devices update their serial input on a rising edge of sclk,
	// so we need to update the mosi output of the core before
	// -> at the falling edge of sclk = set SPI_TX_NEG
	if(auto_cs == 1)
 420:	e3500001 	cmp	r0, #1	; 0x1
		SPI0_CONF = (1<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // auto assert cs
	else
		SPI0_CONF = (0<<SPI_ACS) | (1<<SPI_TX_NEG) | data_size; // manual assert cs
 424:	e3812b01 	orr	r2, r1, #1024	; 0x400
 428:	03e03a0f 	mvneq	r3, #61440	; 0xf000
 42c:	e3811b09 	orr	r1, r1, #9216	; 0x2400
 430:	13e03a0f 	mvnne	r3, #61440	; 0xf000
 434:	05031fcf 	streq	r1, [r3, #-4047]
 438:	15032fcf 	strne	r2, [r3, #-4047]
 43c:	e12fff1e 	bx	lr

00000440 <io_spi0_speed>:
//	set_cmsr(_cmsr);
}

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(spi_clk*2))-1
   void io_spi0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_PRSC = clk_divider; // (sys_clk/(spi_clk*2))-1;
 440:	e3e03a0f 	mvn	r3, #61440	; 0xf000
 444:	e5030fcb 	str	r0, [r3, #-4043]

//	set_cmsr(_cmsr);
}
 448:	e12fff1e 	bx	lr

0000044c <io_spi0_trans>:

// ******************************************************************************
// Sends/receives max 32 bits via SPI, CS and config must be done outside
   unsigned long io_spi0_trans(unsigned long data)
// ******************************************************************************
{
 44c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// spi transmission
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for prev tx to finish
 450:	e5123fcf 	ldr	r3, [r2, #-4047]
 454:	e3130c01 	tst	r3, #256	; 0x100
 458:	1afffffc 	bne	450 <io_spi0_trans+0x4>
	SPI0_DAT0 = data;
 45c:	e5020fbf 	str	r0, [r2, #-4031]
	SPI0_CONF = SPI0_CONF | (1<<SPI_BUSY); // start transmitter
 460:	e5123fcf 	ldr	r3, [r2, #-4047]
 464:	e3833c01 	orr	r3, r3, #256	; 0x100
 468:	e5023fcf 	str	r3, [r2, #-4047]
 46c:	e3e02a0f 	mvn	r2, #61440	; 0xf000
	while((SPI0_CONF & (1<<SPI_BUSY)) != 0); // wait for rx to finish
 470:	e5123fcf 	ldr	r3, [r2, #-4047]
 474:	e3130c01 	tst	r3, #256	; 0x100
 478:	1afffffc 	bne	470 <io_spi0_trans+0x24>
	unsigned long temp = SPI0_DAT0;
 47c:	e5120fbf 	ldr	r0, [r2, #-4031]

//	set_cmsr(_cmsr);
	return temp;
}
 480:	e12fff1e 	bx	lr

00000484 <io_spi0_enable>:

// ******************************************************************************
// Controls the CS of SPI0, enables a connected CS (turns it LOW)
   void io_spi0_enable(unsigned char device)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR | (1<<device);
 484:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 488:	e5113fc7 	ldr	r3, [r1, #-4039]
 48c:	e20000ff 	and	r0, r0, #255	; 0xff
 490:	e3a02001 	mov	r2, #1	; 0x1
 494:	e1833012 	orr	r3, r3, r2, lsl r0
 498:	e5013fc7 	str	r3, [r1, #-4039]

//	set_cmsr(_cmsr);
}
 49c:	e12fff1e 	bx	lr

000004a0 <io_spi0_disable>:

// ******************************************************************************
// Controls the CS of SPI0, disables a connected CS (turns it HIGH)
   void io_spi0_disable(unsigned char device)
// ******************************************************************************
{
 4a0:	e20000ff 	and	r0, r0, #255	; 0xff
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

		SPI0_SCSR = SPI0_SCSR & ~(1<<device);
 4a4:	e3a02001 	mov	r2, #1	; 0x1
 4a8:	e1a02012 	mov	r2, r2, lsl r0
 4ac:	e3e01a0f 	mvn	r1, #61440	; 0xf000
 4b0:	e5113fc7 	ldr	r3, [r1, #-4039]
 4b4:	e1e02002 	mvn	r2, r2
 4b8:	e0033002 	and	r3, r3, r2
 4bc:	e5013fc7 	str	r3, [r1, #-4039]

//	set_cmsr(_cmsr);
}
 4c0:	e12fff1e 	bx	lr

000004c4 <io_i2c0_speed>:




// ###########################################################################################################################
// Inter Intergrated Circuit Interface (I²C_CONTROLLER_0)
// ###########################################################################################################################

// ******************************************************************************
// Configure SPI 0 CLK frequency -> (sys_clk/(5*i2c_clock)-1
   void io_i2c0_speed(unsigned long clk_divider)
// ******************************************************************************
{
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));
		I2C0_CTRL = I2C0_CTRL & ~(1<<I2C_EN); // disable i2c core
 4c4:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 4c8:	e5123f97 	ldr	r3, [r2, #-3991]
		I2C0_PRLO = clk_divider;
		I2C0_PRHI = clk_divider >> 8;
 4cc:	e1a01420 	mov	r1, r0, lsr #8
 4d0:	e3c33080 	bic	r3, r3, #128	; 0x80
 4d4:	e5023f97 	str	r3, [r2, #-3991]
 4d8:	e5020f9f 	str	r0, [r2, #-3999]
 4dc:	e5021f9b 	str	r1, [r2, #-3995]
		I2C0_CTRL = I2C0_CTRL | (1<<I2C_EN); // enable i2c core
 4e0:	e5123f97 	ldr	r3, [r2, #-3991]
 4e4:	e3833080 	orr	r3, r3, #128	; 0x80
 4e8:	e5023f97 	str	r3, [r2, #-3991]
//	set_cmsr(_cmsr);
}
 4ec:	e12fff1e 	bx	lr

000004f0 <io_i2c0_byte_transfer>:

// ******************************************************************************
// Read/write byte from/to I²C slave, max 2 address bytes
   int io_i2c0_byte_transfer(unsigned char rw,        // 'r' read / 'w' write cycle
                             unsigned char id,        // device ID
							 unsigned long data_adr,  // data address
							 unsigned char adr_bytes, // number of adr bytes
							 unsigned char data)      // data byte
// ******************************************************************************
{
 4f0:	e92d4030 	stmdb	sp!, {r4, r5, lr}
//	unsigned long _cmsr = get_cmsr();
//	set_cmsr(_cmsr  | (1<<CMSR_IRQ) | (1<<CMSR_FIQ));

	// transfer slave identification address
	I2C0_DATA = id & 0xFE;                  // device id and write
	I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
 4f4:	e3a0c090 	mov	ip, #144	; 0x90
 4f8:	e20140fe 	and	r4, r1, #254	; 0xfe
 4fc:	e3e0ea0f 	mvn	lr, #61440	; 0xf000
 500:	e5dd500f 	ldrb	r5, [sp, #15]
 504:	e20000ff 	and	r0, r0, #255	; 0xff
 508:	e50e4f93 	str	r4, [lr, #-3987]
 50c:	e20110ff 	and	r1, r1, #255	; 0xff
 510:	e50ecfaf 	str	ip, [lr, #-4015]
 514:	e1a04002 	mov	r4, r2
 518:	e203c0ff 	and	ip, r3, #255	; 0xff
	while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 51c:	e51e3faf 	ldr	r3, [lr, #-4015]
 520:	e3130002 	tst	r3, #2	; 0x2
 524:	1afffffc 	bne	51c <io_i2c0_byte_transfer+0x2c>
	if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 528:	e51e3faf 	ldr	r3, [lr, #-4015]
 52c:	e3130080 	tst	r3, #128	; 0x80
 530:	13e00000 	mvnne	r0, #0	; 0x0
 534:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
//		set_cmsr(_cmsr);
		return -1;
	}

	// transfer data address
	while(adr_bytes != 0){
 538:	e35c0000 	cmp	ip, #0	; 0x0
 53c:	0a000012 	beq	58c <io_i2c0_byte_transfer+0x9c>
		adr_bytes--;
 540:	e24c3001 	sub	r3, ip, #1	; 0x1
 544:	e203c0ff 	and	ip, r3, #255	; 0xff
		if(adr_bytes == 1)
 548:	e35c0001 	cmp	ip, #1	; 0x1
			I2C0_DATA = data_adr >> 8;          // high byte
 54c:	01a02424 	moveq	r2, r4, lsr #8
 550:	03e03a0f 	mvneq	r3, #61440	; 0xf000
		else
			I2C0_DATA = data_adr;               // low byte
 554:	13e03a0f 	mvnne	r3, #61440	; 0xf000
 558:	05032f93 	streq	r2, [r3, #-3987]
 55c:	15034f93 	strne	r4, [r3, #-3987]
		I2C0_CMD = (1<<I2C_WR);                 // write cycle
 560:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 564:	e3a03010 	mov	r3, #16	; 0x10
 568:	e5023faf 	str	r3, [r2, #-4015]
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 56c:	e5123faf 	ldr	r3, [r2, #-4015]
 570:	e3130002 	tst	r3, #2	; 0x2
 574:	1afffffc 	bne	56c <io_i2c0_byte_transfer+0x7c>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 578:	e5123faf 	ldr	r3, [r2, #-4015]
 57c:	e3130080 	tst	r3, #128	; 0x80
 580:	0affffec 	beq	538 <io_i2c0_byte_transfer+0x48>
 584:	e3e00001 	mvn	r0, #1	; 0x1
 588:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -2;
		}
	}

	if(rw == 'w'){
 58c:	e3500077 	cmp	r0, #119	; 0x77
 590:	1a00000c 	bne	5c8 <io_i2c0_byte_transfer+0xd8>
		// write adressed byte
		I2C0_DATA = data;                       // send data
 594:	e3e03a0f 	mvn	r3, #61440	; 0xf000
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_WR);  // stop condition and write cycle
 598:	e3a02050 	mov	r2, #80	; 0x50
 59c:	e5035f93 	str	r5, [r3, #-3987]
 5a0:	e5032faf 	str	r2, [r3, #-4015]
 5a4:	e1a02003 	mov	r2, r3
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
 5a8:	e5123faf 	ldr	r3, [r2, #-4015]
 5ac:	e3130002 	tst	r3, #2	; 0x2
 5b0:	1afffffc 	bne	5a8 <io_i2c0_byte_transfer+0xb8>
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
 5b4:	e5123faf 	ldr	r3, [r2, #-4015]
 5b8:	e2130080 	ands	r0, r3, #128	; 0x80
 5bc:	08bd8030 	ldmeqia	sp!, {r4, r5, pc}
//			set_cmsr(_cmsr);
			return -3;
		}
		else{
//			set_cmsr(_cmsr);
			return 0;
		}
	}

	if(rw == 'r'){
		// re-send control byte - this time with read-bit
		I2C0_DATA = id | 0x01;                  // device id and READ
		I2C0_CMD = (1<<I2C_STA) | (1<<I2C_WR);  // start condition and write cycle
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		if((I2C0_STAT & (1<<I2C_RXACK)) != 0){  // ack received?
//			set_cmsr(_cmsr);
			return -3;
		}
		// read adressed byte
		I2C0_CMD = (1<<I2C_STO) | (1<<I2C_RD) | (1<<I2C_ACK);
		while((I2C0_STAT & (1<<I2C_TIP)) != 0); // wait for transfer to finish
		return I2C0_DATA;
 5c0:	e3e00002 	mvn	r0, #2	; 0x2
	}

//	set_cmsr(_cmsr);
	return -4;
}
 5c4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
 5c8:	e3500072 	cmp	r0, #114	; 0x72
 5cc:	13e00003 	mvnne	r0, #3	; 0x3
 5d0:	18bd8030 	ldmneia	sp!, {r4, r5, pc}
 5d4:	e3813001 	orr	r3, r1, #1	; 0x1
 5d8:	e3e02a0f 	mvn	r2, #61440	; 0xf000
 5dc:	e3a01090 	mov	r1, #144	; 0x90
 5e0:	e5023f93 	str	r3, [r2, #-3987]
 5e4:	e5021faf 	str	r1, [r2, #-4015]
 5e8:	e5123faf 	ldr	r3, [r2, #-4015]
 5ec:	e3130002 	tst	r3, #2	; 0x2
 5f0:	1afffffc 	bne	5e8 <io_i2c0_byte_transfer+0xf8>
 5f4:	e5123faf 	ldr	r3, [r2, #-4015]
 5f8:	e3130080 	tst	r3, #128	; 0x80
 5fc:	1affffef 	bne	5c0 <io_i2c0_byte_transfer+0xd0>
 600:	e3a03068 	mov	r3, #104	; 0x68
 604:	e5023faf 	str	r3, [r2, #-4015]
 608:	e3e00a0f 	mvn	r0, #61440	; 0xf000
 60c:	e5103faf 	ldr	r3, [r0, #-4015]
 610:	e3130002 	tst	r3, #2	; 0x2
 614:	1afffffc 	bne	60c <io_i2c0_byte_transfer+0x11c>
 618:	e5100f93 	ldr	r0, [r0, #-3987]
 61c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

00000620 <get_syscpreg>:




// ###########################################################################################################################
// System
// ###########################################################################################################################

// ******************************************************************************
// read system coprocessor register x
   unsigned long get_syscpreg(unsigned char index)
// ******************************************************************************
{
 620:	e20000ff 	and	r0, r0, #255	; 0xff
	unsigned long _cp_val;
	switch(index){
 624:	e350000f 	cmp	r0, #15	; 0xf
 628:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
 62c:	ea00000f 	b	670 <.text+0x670>
 630:	000006f0 	streqd	r0, [r0], -r0
 634:	000006e8 	andeq	r0, r0, r8, ror #13
 638:	000006e0 	andeq	r0, r0, r0, ror #13
 63c:	000006d8 	ldreqd	r0, [r0], -r8
 640:	000006d0 	ldreqd	r0, [r0], -r0
 644:	000006c8 	andeq	r0, r0, r8, asr #13
 648:	000006c0 	andeq	r0, r0, r0, asr #13
 64c:	000006b8 	streqh	r0, [r0], -r8
 650:	000006b0 	streqh	r0, [r0], -r0
 654:	000006a8 	andeq	r0, r0, r8, lsr #13
 658:	000006a0 	andeq	r0, r0, r0, lsr #13
 65c:	00000698 	muleq	r0, r8, r6
 660:	00000690 	muleq	r0, r0, r6
 664:	00000688 	andeq	r0, r0, r8, lsl #13
 668:	00000680 	andeq	r0, r0, r0, lsl #13
 66c:	00000678 	andeq	r0, r0, r8, ror r6
 670:	e3a00000 	mov	r0, #0	; 0x0
 674:	e12fff1e 	bx	lr
		case ID_REG_0:   asm volatile ("mrc p15,0,%0, c0, c0" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_1:   asm volatile ("mrc p15,0,%0, c1, c1" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ID_REG_2:   asm volatile ("mrc p15,0,%0, c2, c2" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 3:          asm volatile ("mrc p15,0,%0, c3, c3" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 4:          asm volatile ("mrc p15,0,%0, c4, c4" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 5:          asm volatile ("mrc p15,0,%0, c5, c5" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_CTRL_0: asm volatile ("mrc p15,0,%0, c6, c6" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 7:          asm volatile ("mrc p15,0,%0, c7, c7" : "=r" (_cp_val) : /* no inputs */  ); break;
		case CSTAT:      asm volatile ("mrc p15,0,%0, c8, c8" : "=r" (_cp_val) : /* no inputs */  ); break;
		case ADR_FB:     asm volatile ("mrc p15,0,%0, c9, c9" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 10:         asm volatile ("mrc p15,0,%0,c10,c10" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_POLY:  asm volatile ("mrc p15,0,%0,c11,c11" : "=r" (_cp_val) : /* no inputs */  ); break;
		case LFSR_DATA:  asm volatile ("mrc p15,0,%0,c12,c12" : "=r" (_cp_val) : /* no inputs */  ); break;
		case SYS_IO:     asm volatile ("mrc p15,0,%0,c13,c13" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 14:         asm volatile ("mrc p15,0,%0,c14,c14" : "=r" (_cp_val) : /* no inputs */  ); break;
		case 15:         asm volatile ("mrc p15,0,%0,c15,c15" : "=r" (_cp_val) : /* no inputs */  ); break;
 678:	ee1f0f1f 	mrc	15, 0, r0, cr15, cr15, {0}
		default:         _cp_val = 0; break;
	}
	return _cp_val;
}
 67c:	e12fff1e 	bx	lr
 680:	ee1e0f1e 	mrc	15, 0, r0, cr14, cr14, {0}
 684:	e12fff1e 	bx	lr
 688:	ee1d0f1d 	mrc	15, 0, r0, cr13, cr13, {0}
 68c:	e12fff1e 	bx	lr
 690:	ee1c0f1c 	mrc	15, 0, r0, cr12, cr12, {0}
 694:	e12fff1e 	bx	lr
 698:	ee1b0f1b 	mrc	15, 0, r0, cr11, cr11, {0}
 69c:	e12fff1e 	bx	lr
 6a0:	ee1a0f1a 	mrc	15, 0, r0, cr10, cr10, {0}
 6a4:	e12fff1e 	bx	lr
 6a8:	ee190f19 	mrc	15, 0, r0, cr9, cr9, {0}
 6ac:	e12fff1e 	bx	lr
 6b0:	ee180f18 	mrc	15, 0, r0, cr8, cr8, {0}
 6b4:	e12fff1e 	bx	lr
 6b8:	ee170f17 	mrc	15, 0, r0, cr7, cr7, {0}
 6bc:	e12fff1e 	bx	lr
 6c0:	ee160f16 	mrc	15, 0, r0, cr6, cr6, {0}
 6c4:	e12fff1e 	bx	lr
 6c8:	ee150f15 	mrc	15, 0, r0, cr5, cr5, {0}
 6cc:	e12fff1e 	bx	lr
 6d0:	ee140f14 	mrc	15, 0, r0, cr4, cr4, {0}
 6d4:	e12fff1e 	bx	lr
 6d8:	ee130f13 	mrc	15, 0, r0, cr3, cr3, {0}
 6dc:	e12fff1e 	bx	lr
 6e0:	ee120f12 	mrc	15, 0, r0, cr2, cr2, {0}
 6e4:	e12fff1e 	bx	lr
 6e8:	ee110f11 	mrc	15, 0, r0, cr1, cr1, {0}
 6ec:	e12fff1e 	bx	lr
 6f0:	ee100f10 	mrc	15, 0, r0, cr0, cr0, {0}
 6f4:	e12fff1e 	bx	lr

000006f8 <set_syscpreg>:

// ******************************************************************************
// write system coprocessor register x
   void set_syscpreg(unsigned long _cp_val, unsigned char index)
// ******************************************************************************
{
 6f8:	e20110ff 	and	r1, r1, #255	; 0xff
	switch(index){
 6fc:	e2411006 	sub	r1, r1, #6	; 0x6
 700:	e3510007 	cmp	r1, #7	; 0x7
 704:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
 708:	ea000008 	b	730 <.text+0x730>
 70c:	00000734 	andeq	r0, r0, r4, lsr r7
 710:	00000730 	andeq	r0, r0, r0, lsr r7
 714:	00000730 	andeq	r0, r0, r0, lsr r7
 718:	00000730 	andeq	r0, r0, r0, lsr r7
 71c:	00000730 	andeq	r0, r0, r0, lsr r7
 720:	0000073c 	andeq	r0, r0, ip, lsr r7
 724:	00000744 	andeq	r0, r0, r4, asr #14
 728:	0000072c 	andeq	r0, r0, ip, lsr #14
//		case ID_REG_0:   asm volatile ("mcr p15,0,%0, c0, c0,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_1:   asm volatile ("mcr p15,0,%0, c1, c1,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ID_REG_2:   asm volatile ("mcr p15,0,%0, c2, c2,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 3:          asm volatile ("mcr p15,0,%0, c3, c3,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 4:          asm volatile ("mcr p15,0,%0, c4, c4,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 5:          asm volatile ("mcr p15,0,%0, c5, c5,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_CTRL_0: asm volatile ("mcr p15,0,%0, c6, c6,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 7:          asm volatile ("mcr p15,0,%0, c7, c7,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case CSTAT:      asm volatile ("mcr p15,0,%0, c8, c8,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case ADR_FB:     asm volatile ("mcr p15,0,%0, c9, c9,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 10:         asm volatile ("mcr p15,0,%0,c10,c10,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_POLY:  asm volatile ("mcr p15,0,%0,c11,c11,0" : /* no outputs */ : "r" (_cp_val)); break;
		case LFSR_DATA:  asm volatile ("mcr p15,0,%0,c12,c12,0" : /* no outputs */ : "r" (_cp_val)); break;
		case SYS_IO:     asm volatile ("mcr p15,0,%0,c13,c13,0" : /* no outputs */ : "r" (_cp_val)); break;
 72c:	ee0d0f1d 	mcr	15, 0, r0, cr13, cr13, {0}
 730:	e12fff1e 	bx	lr
 734:	ee060f16 	mcr	15, 0, r0, cr6, cr6, {0}
 738:	e12fff1e 	bx	lr
 73c:	ee0b0f1b 	mcr	15, 0, r0, cr11, cr11, {0}
 740:	e12fff1e 	bx	lr
 744:	ee0c0f1c 	mcr	15, 0, r0, cr12, cr12, {0}
 748:	e12fff1e 	bx	lr

0000074c <uart0_printf>:
// ############################################################################################
// Print text string via UART 0
   const char *uart0_printf(const char *string)
// ############################################################################################
{
 74c:	e92d4010 	stmdb	sp!, {r4, lr}
 750:	e1a04000 	mov	r4, r0
	char ch;

	while ((ch = *string)){
 754:	e5d00000 	ldrb	r0, [r0]
 758:	e3500000 	cmp	r0, #0	; 0x0
 75c:	1a000003 	bne	770 <uart0_printf+0x24>
 760:	ea000005 	b	77c <uart0_printf+0x30>
 764:	e5f40001 	ldrb	r0, [r4, #1]!
 768:	e3500000 	cmp	r0, #0	; 0x0
 76c:	0a000002 	beq	77c <uart0_printf+0x30>
		if (io_uart0_send_byte(ch)<=0)
 770:	ebffff22 	bl	400 <io_uart0_send_byte>
 774:	e3500000 	cmp	r0, #0	; 0x0
 778:	cafffff9 	bgt	764 <uart0_printf+0x18>
			break;
		string++;
	}
	return string;
}
 77c:	e1a00004 	mov	r0, r4
 780:	e8bd8010 	ldmia	sp!, {r4, pc}

00000784 <uart0_scanf>:

// ############################################################################################
// Read text string via UART 0
   void uart0_scanf(unsigned char *buffer, int length, unsigned char en_echo)
// ############################################################################################
{
 784:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
	int temp = 0;

	while(length > 0){
 788:	e2514000 	subs	r4, r1, #0	; 0x0
 78c:	e1a05000 	mov	r5, r0
 790:	e20260ff 	and	r6, r2, #255	; 0xff
 794:	d8bd8070 	ldmleia	sp!, {r4, r5, r6, pc}
		temp = io_uart0_read_byte();
 798:	ebffff12 	bl	3e8 <io_uart0_read_byte>
		if(temp != -1){
 79c:	e3700001 	cmn	r0, #1	; 0x1
			temp = (unsigned char)(temp & 0x000000FF);
 7a0:	e20030ff 	and	r3, r0, #255	; 0xff
 7a4:	0a000005 	beq	7c0 <uart0_scanf+0x3c>
			*buffer++ = temp;
			if(en_echo == 1)
 7a8:	e3560001 	cmp	r6, #1	; 0x1
 7ac:	e5c53000 	strb	r3, [r5]
				io_uart0_send_byte(temp); // echo
 7b0:	e1a00003 	mov	r0, r3
 7b4:	e2855001 	add	r5, r5, #1	; 0x1
 7b8:	0a000003 	beq	7cc <uart0_scanf+0x48>
			length--;
 7bc:	e2444001 	sub	r4, r4, #1	; 0x1
 7c0:	e3540000 	cmp	r4, #0	; 0x0
 7c4:	cafffff3 	bgt	798 <uart0_scanf+0x14>
 7c8:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 7cc:	ebffff0b 	bl	400 <io_uart0_send_byte>
 7d0:	eafffff9 	b	7bc <uart0_scanf+0x38>

000007d4 <uart0_print_buffer>:
		}
	}
}

// ############################################################################################
// Print character buffer via UART 0
   void uart0_print_buffer(unsigned char *buffer, int size)
// ############################################################################################
{
 7d4:	e92d4030 	stmdb	sp!, {r4, r5, lr}
	unsigned char char_buffer = 0;
	while(size > 0){
 7d8:	e2514000 	subs	r4, r1, #0	; 0x0
 7dc:	e1a05000 	mov	r5, r0
 7e0:	d8bd8030 	ldmleia	sp!, {r4, r5, pc}
		char_buffer = *buffer++;
		io_uart0_send_byte((int)char_buffer);
 7e4:	e4d50001 	ldrb	r0, [r5], #1
 7e8:	ebffff04 	bl	400 <io_uart0_send_byte>
 7ec:	e2544001 	subs	r4, r4, #1	; 0x1
 7f0:	1afffffb 	bne	7e4 <uart0_print_buffer+0x10>
 7f4:	e8bd8030 	ldmia	sp!, {r4, r5, pc}

000007f8 <memTestDataBus>:
 *
 **********************************************************************/
datum
memTestDataBus(volatile datum * address)
{
 7f8:	e1a02000 	mov	r2, r0
 7fc:	e3a00001 	mov	r0, #1	; 0x1
    datum pattern;


    /*
     * Perform a walking 1's test at the given address.
     */
    for (pattern = 1; pattern != 0; pattern <<= 1)
    {
        /*
         * Write the test pattern.
         */
        *address = pattern;
 800:	e5820000 	str	r0, [r2]

        /*
         * Read it back (immediately is okay for this test).
         */
        if (*address != pattern) 
 804:	e5923000 	ldr	r3, [r2]
 808:	e1530000 	cmp	r3, r0
 80c:	112fff1e 	bxne	lr
 810:	e1b00080 	movs	r0, r0, lsl #1
 814:	1afffff9 	bne	800 <memTestDataBus+0x8>
        {
            return (pattern);
        }
    }

    return (0);

}   /* memTestDataBus() */
 818:	e12fff1e 	bx	lr

0000081c <memTestAddressBus>:


/**********************************************************************
 *
 * Function:    memTestAddressBus()
 *
 * Description: Test the address bus wiring in a memory region by
 *              performing a walking 1's test on the relevant bits
 *              of the address and checking for aliasing. This test
 *              will find single-bit address failures such as stuck
 *              -high, stuck-low, and shorted pins.  The base address
 *              and size of the region are selected by the caller.
 *
 * Notes:       For best results, the selected base address should
 *              have enough LSB 0's to guarantee single address bit
 *              changes.  For example, to test a 64-Kbyte region, 
 *              select a base address on a 64-Kbyte boundary.  Also, 
 *              select the region size as a power-of-two--if at all 
 *              possible.
 *
 * Returns:     NULL if the test succeeds.  
 *              A non-zero result is the first address at which an
 *              aliasing problem was uncovered.  By examining the
 *              contents of memory, it may be possible to gather
 *              additional information about the problem.
 *
 **********************************************************************/
datum * 
memTestAddressBus(volatile datum * baseAddress, unsigned long nBytes)
{
    unsigned long addressMask = (nBytes/sizeof(datum) - 1);
 81c:	e1a01121 	mov	r1, r1, lsr #2
 820:	e92d4030 	stmdb	sp!, {r4, r5, lr}
 824:	e241e001 	sub	lr, r1, #1	; 0x1
    unsigned long offset;
    unsigned long testOffset;

    datum pattern     = (datum) 0xAAAAAAAA;
    datum antipattern = (datum) 0x55555555;


    /*
     * Write the default pattern at each of the power-of-two offsets.
     */
    for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
 828:	e21e1001 	ands	r1, lr, #1	; 0x1
 82c:	0a00004a 	beq	95c <memTestAddressBus+0x140>
 830:	e3a01caa 	mov	r1, #43520	; 0xaa00
 834:	e28110aa 	add	r1, r1, #170	; 0xaa
 838:	e1811801 	orr	r1, r1, r1, lsl #16
 83c:	e3a02001 	mov	r2, #1	; 0x1
    {
        baseAddress[offset] = pattern;
 840:	e1a03102 	mov	r3, r2, lsl #2
 844:	e1a02082 	mov	r2, r2, lsl #1
 848:	e11e0002 	tst	lr, r2
 84c:	e7801003 	str	r1, [r0, r3]
 850:	1afffffa 	bne	840 <memTestAddressBus+0x24>
    }

    /* 
     * Check for address bits stuck high.
     */
    testOffset = 0;
    baseAddress[testOffset] = antipattern;
 854:	e3a03c55 	mov	r3, #21760	; 0x5500
 858:	e2833055 	add	r3, r3, #85	; 0x55
 85c:	e1a05000 	mov	r5, r0
 860:	e1833803 	orr	r3, r3, r3, lsl #16
 864:	e4853004 	str	r3, [r5], #4

    for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
    {
        if (baseAddress[offset] != pattern)
 868:	e5902004 	ldr	r2, [r0, #4]
 86c:	e1520001 	cmp	r2, r1
 870:	11a0c005 	movne	ip, r5
 874:	1a000035 	bne	950 <memTestAddressBus+0x134>
        {
            return ((datum *) &baseAddress[offset]);
 878:	e3a01001 	mov	r1, #1	; 0x1
 87c:	ea000002 	b	88c <memTestAddressBus+0x70>
 880:	e7903003 	ldr	r3, [r0, r3]
 884:	e1530002 	cmp	r3, r2
 888:	1a000030 	bne	950 <memTestAddressBus+0x134>
 88c:	e1a01081 	mov	r1, r1, lsl #1
 890:	e3a02caa 	mov	r2, #43520	; 0xaa00
 894:	e28220aa 	add	r2, r2, #170	; 0xaa
 898:	e1a03101 	mov	r3, r1, lsl #2
 89c:	e11e0001 	tst	lr, r1
 8a0:	e1822802 	orr	r2, r2, r2, lsl #16
 8a4:	e080c003 	add	ip, r0, r3
 8a8:	1afffff4 	bne	880 <memTestAddressBus+0x64>
        }
    }

    baseAddress[testOffset] = pattern;
 8ac:	e3a03caa 	mov	r3, #43520	; 0xaa00

    /*
     * Check for address bits stuck low or shorted.
     */
    for (testOffset = 1; (testOffset & addressMask) != 0; testOffset <<= 1)
    {
        baseAddress[testOffset] = antipattern;
 8b0:	e3a02c55 	mov	r2, #21760	; 0x5500
 8b4:	e28330aa 	add	r3, r3, #170	; 0xaa
 8b8:	e2822055 	add	r2, r2, #85	; 0x55
 8bc:	e1833803 	orr	r3, r3, r3, lsl #16
 8c0:	e1822802 	orr	r2, r2, r2, lsl #16
 8c4:	e5803000 	str	r3, [r0]
 8c8:	e5852000 	str	r2, [r5]

		if (baseAddress[0] != pattern)
 8cc:	e5901000 	ldr	r1, [r0]
 8d0:	e1510003 	cmp	r1, r3
 8d4:	03a04001 	moveq	r4, #1	; 0x1
 8d8:	1a000019 	bne	944 <memTestAddressBus+0x128>
 8dc:	e3a01001 	mov	r1, #1	; 0x1
		{
			return ((datum *) &baseAddress[testOffset]);
		}

        for (offset = 1; (offset & addressMask) != 0; offset <<= 1)
        {
            if ((baseAddress[offset] != pattern) && (offset != testOffset))
 8e0:	e1a03101 	mov	r3, r1, lsl #2
 8e4:	e3a0ccaa 	mov	ip, #43520	; 0xaa00
 8e8:	e7902003 	ldr	r2, [r0, r3]
 8ec:	e28cc0aa 	add	ip, ip, #170	; 0xaa
 8f0:	e18cc80c 	orr	ip, ip, ip, lsl #16
 8f4:	e152000c 	cmp	r2, ip
 8f8:	0a000001 	beq	904 <memTestAddressBus+0xe8>
 8fc:	e1510004 	cmp	r1, r4
 900:	1a00000f 	bne	944 <memTestAddressBus+0x128>
 904:	e1a01081 	mov	r1, r1, lsl #1
 908:	e11e0001 	tst	lr, r1
 90c:	1afffff3 	bne	8e0 <memTestAddressBus+0xc4>
 910:	e1a04084 	mov	r4, r4, lsl #1
 914:	e01e2004 	ands	r2, lr, r4
            {
                return ((datum *) &baseAddress[testOffset]);
            }
        }

        baseAddress[testOffset] = pattern;
 918:	e585c000 	str	ip, [r5]
 91c:	0a000018 	beq	984 <memTestAddressBus+0x168>
 920:	e3a03c55 	mov	r3, #21760	; 0x5500
 924:	e2833055 	add	r3, r3, #85	; 0x55
 928:	e1a01104 	mov	r1, r4, lsl #2
 92c:	e1833803 	orr	r3, r3, r3, lsl #16
 930:	e7803001 	str	r3, [r0, r1]
 934:	e5902000 	ldr	r2, [r0]
 938:	e152000c 	cmp	r2, ip
 93c:	e0805001 	add	r5, r0, r1
 940:	0affffe5 	beq	8dc <memTestAddressBus+0xc0>
 944:	e1a01005 	mov	r1, r5
    }

    return (NULL);

}   /* memTestAddressBus() */
 948:	e1a00001 	mov	r0, r1
 94c:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
 950:	e1a0100c 	mov	r1, ip
 954:	e1a00001 	mov	r0, r1
 958:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
 95c:	e3a03c55 	mov	r3, #21760	; 0x5500
 960:	e3a02caa 	mov	r2, #43520	; 0xaa00
 964:	e2833055 	add	r3, r3, #85	; 0x55
 968:	e28220aa 	add	r2, r2, #170	; 0xaa
 96c:	e1833803 	orr	r3, r3, r3, lsl #16
 970:	e1822802 	orr	r2, r2, r2, lsl #16
 974:	e5803000 	str	r3, [r0]
 978:	e5802000 	str	r2, [r0]
 97c:	e1a00001 	mov	r0, r1
 980:	e8bd8030 	ldmia	sp!, {r4, r5, pc}
 984:	e1a01002 	mov	r1, r2
 988:	eaffffee 	b	948 <memTestAddressBus+0x12c>

0000098c <memTestDevice1>:


/**********************************************************************
 *
 * Function:    memTestDevice()
 *
 * Description: Test the integrity of a physical memory device by
 *              performing an increment/decrement test over the
 *              entire region.  In the process every storage bit 
 *              in the device is tested as a zero and a one.  The
 *              base address and the size of the region are
 *              selected by the caller.
 *
 * Notes:       
 *
 * Returns:     NULL if the test succeeds.
 *
 *              A non-zero result is the first address at which an
 *              incorrect value was read back.  By examining the
 *              contents of memory, it may be possible to gather
 *              additional information about the problem.
 *
 **********************************************************************/
datum * 
memTestDevice1(volatile datum * baseAddress, unsigned long nBytes)	
{
    unsigned long offset;
    unsigned long nWords = nBytes / sizeof(datum);

    datum pattern;
    datum antipattern;


    /*
     * Fill memory with a known pattern.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 98c:	e1b01121 	movs	r1, r1, lsr #2
 990:	0a000013 	beq	9e4 <memTestDevice1+0x58>
 994:	e3a03001 	mov	r3, #1	; 0x1
 998:	e1a02000 	mov	r2, r0
 99c:	e081c003 	add	ip, r1, r3
    {
        baseAddress[offset] = pattern;
 9a0:	e4823004 	str	r3, [r2], #4
 9a4:	e2833001 	add	r3, r3, #1	; 0x1
 9a8:	e15c0003 	cmp	ip, r3
 9ac:	1afffffb 	bne	9a0 <memTestDevice1+0x14>
    }

    /*
     * Check each location and invert it for the second pass.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
    {
        if (baseAddress[offset] != pattern)
 9b0:	e5903000 	ldr	r3, [r0]
 9b4:	e3530001 	cmp	r3, #1	; 0x1
 9b8:	112fff1e 	bxne	lr
        {
            return ((datum *) &baseAddress[offset]);
 9bc:	e2802004 	add	r2, r0, #4	; 0x4
 9c0:	e1a0c003 	mov	ip, r3
 9c4:	ea000002 	b	9d4 <memTestDevice1+0x48>
 9c8:	e4923004 	ldr	r3, [r2], #4
 9cc:	e153000c 	cmp	r3, ip
 9d0:	1a000005 	bne	9ec <memTestDevice1+0x60>
 9d4:	e151000c 	cmp	r1, ip
 9d8:	e1a00002 	mov	r0, r2
 9dc:	e28cc001 	add	ip, ip, #1	; 0x1
 9e0:	1afffff8 	bne	9c8 <memTestDevice1+0x3c>
 9e4:	e3a00000 	mov	r0, #0	; 0x0
        }
 
    }
    return (NULL);

}   /* memTestDevice1() */
 9e8:	e12fff1e 	bx	lr
 9ec:	e12fff1e 	bx	lr

000009f0 <memTestDevice2>:
datum * 
memTestDevice2(volatile datum * baseAddress, unsigned long nBytes)	
{
    unsigned long offset;
    unsigned long nWords = nBytes / sizeof(datum);

    datum pattern;
    datum antipattern;

    /*
     * Check each location and invert it for the second pass.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
 9f0:	e1b01121 	movs	r1, r1, lsr #2
 9f4:	e52de004 	str	lr, [sp, #-4]!
 9f8:	0a000015 	beq	a54 <memTestDevice2+0x64>
 9fc:	e3a02001 	mov	r2, #1	; 0x1
 a00:	e1a0c000 	mov	ip, r0
 a04:	e081e002 	add	lr, r1, r2
    {
        antipattern = ~pattern;
 a08:	e1e03002 	mvn	r3, r2
 a0c:	e2822001 	add	r2, r2, #1	; 0x1
 a10:	e15e0002 	cmp	lr, r2
        baseAddress[offset] = antipattern;
 a14:	e48c3004 	str	r3, [ip], #4
 a18:	1afffffa 	bne	a08 <memTestDevice2+0x18>
    }

    /*
     * Check each location for the inverted pattern and zero it.
     */
    for (pattern = 1, offset = 0; offset < nWords; pattern++, offset++)
    {
        antipattern = ~pattern;
        if (baseAddress[offset] != antipattern)
 a1c:	e5903000 	ldr	r3, [r0]
 a20:	e3730002 	cmn	r3, #2	; 0x2
 a24:	149df004 	ldrne	pc, [sp], #4
        {
            return ((datum *) &baseAddress[offset]);
 a28:	e2802004 	add	r2, r0, #4	; 0x4
 a2c:	e3a0e001 	mov	lr, #1	; 0x1
 a30:	ea000002 	b	a40 <memTestDevice2+0x50>
 a34:	e4923004 	ldr	r3, [r2], #4
 a38:	e15c0003 	cmp	ip, r3
 a3c:	1a000006 	bne	a5c <memTestDevice2+0x6c>
 a40:	e151000e 	cmp	r1, lr
 a44:	e28ee001 	add	lr, lr, #1	; 0x1
 a48:	e1a00002 	mov	r0, r2
 a4c:	e1e0c00e 	mvn	ip, lr
 a50:	1afffff7 	bne	a34 <memTestDevice2+0x44>
 a54:	e3a00000 	mov	r0, #0	; 0x0
        }
    }

    return (NULL);

}   /* memTestDevice2() */
 a58:	e49df004 	ldr	pc, [sp], #4
 a5c:	e49df004 	ldr	pc, [sp], #4

00000a60 <long_to_hex_string>:
   void long_to_hex_string(unsigned long data,    // max 32 bit data word
                           unsigned char *buffer, // buffer to store the string
						   unsigned char numbers) // number of places, max 8
// ############################################################################################
{
 a60:	e92d4010 	stmdb	sp!, {r4, lr}
 a64:	e20240ff 	and	r4, r2, #255	; 0xff
	unsigned char temp_char = 0;
	unsigned long temp_data = 0;

	// fit into range
	if(numbers > 8)
 a68:	e3540008 	cmp	r4, #8	; 0x8
 a6c:	83a04008 	movhi	r4, #8	; 0x8
 a70:	8a000001 	bhi	a7c <long_to_hex_string+0x1c>
		numbers = 8;
	if(numbers < 1)
 a74:	e3540000 	cmp	r4, #0	; 0x0
		numbers = 1;

	while(numbers > 0){
		// isolate one 4-bit value
		if(numbers > 1)
			temp_data = data >> ((numbers-1)*4);
		else
			temp_data = data;
		temp_data = temp_data & 0x0000000F;
		numbers--;

		// convert 4-bit value temp_data to char temp_char
		if(temp_data < 10)
			temp_char = '0' + temp_data;
		else
			temp_char = 'A' + temp_data - 10;

		// save character
		*buffer++ = temp_char;
	}

	*buffer++ = 0; // terminate string
}
 a78:	03a04001 	moveq	r4, #1	; 0x1
 a7c:	e1a02001 	mov	r2, r1
 a80:	e1a0e004 	mov	lr, r4
 a84:	e1a0310e 	mov	r3, lr, lsl #2
 a88:	e35e0001 	cmp	lr, #1	; 0x1
 a8c:	e2433004 	sub	r3, r3, #4	; 0x4
 a90:	e1a0c000 	mov	ip, r0
 a94:	81a0c330 	movhi	ip, r0, lsr r3
 a98:	e24e3001 	sub	r3, lr, #1	; 0x1
 a9c:	e20cc00f 	and	ip, ip, #15	; 0xf
 aa0:	e203e0ff 	and	lr, r3, #255	; 0xff
 aa4:	e35c0009 	cmp	ip, #9	; 0x9
 aa8:	e28c3030 	add	r3, ip, #48	; 0x30
 aac:	828c3037 	addhi	r3, ip, #55	; 0x37
 ab0:	e35e0000 	cmp	lr, #0	; 0x0
 ab4:	e4c23001 	strb	r3, [r2], #1
 ab8:	1afffff1 	bne	a84 <long_to_hex_string+0x24>
 abc:	e2443001 	sub	r3, r4, #1	; 0x1
 ac0:	e20330ff 	and	r3, r3, #255	; 0xff
 ac4:	e0813003 	add	r3, r1, r3
 ac8:	e5c3e001 	strb	lr, [r3, #1]
 acc:	e8bd8010 	ldmia	sp!, {r4, pc}

00000ad0 <main>:

int
main(void)
{
 ad0:	e92d4070 	stmdb	sp!, {r4, r5, r6, lr}
    int i, result = 0;
	unsigned char str[10]="\0";
 ad4:	e59f3198 	ldr	r3, [pc, #408]	; c74 <.text+0xc74>
 ad8:	e1d330b0 	ldrh	r3, [r3]
 adc:	e24dd00c 	sub	sp, sp, #12	; 0xc
 ae0:	e1cd30b2 	strh	r3, [sp, #2]
	
	datum *result_ptr=NULL;
	

     uart0_printf("Starting MEMTEST tests\r\n");
 ae4:	e59f018c 	ldr	r0, [pc, #396]	; c78 <.text+0xc78>
 ae8:	e3a03000 	mov	r3, #0	; 0x0
 aec:	e1cd30b4 	strh	r3, [sp, #4]
 af0:	e1cd30b6 	strh	r3, [sp, #6]
 af4:	e1cd30b8 	strh	r3, [sp, #8]
 af8:	e1cd30ba 	strh	r3, [sp, #10]
     uart0_printf("BASE ADDRESS:  ");
     long_to_hex_string((unsigned long ) BASE_ADDRESS, str, 8);
 afc:	e28d5002 	add	r5, sp, #2	; 0x2
 b00:	ebffff11 	bl	74c <uart0_printf>
 b04:	e59f0170 	ldr	r0, [pc, #368]	; c7c <.text+0xc7c>
 b08:	ebffff0f 	bl	74c <uart0_printf>
 b0c:	e1a01005 	mov	r1, r5
 b10:	e3a02008 	mov	r2, #8	; 0x8
 b14:	e3a00402 	mov	r0, #33554432	; 0x2000000
 b18:	ebffffd0 	bl	a60 <long_to_hex_string>
     uart0_printf(str);uart0_printf("\r\n");
 b1c:	e1a00005 	mov	r0, r5
 b20:	ebffff09 	bl	74c <uart0_printf>
 b24:	e59f0154 	ldr	r0, [pc, #340]	; c80 <.text+0xc80>
 b28:	ebffff07 	bl	74c <uart0_printf>
     uart0_printf("Number of Bytes:  ");
 b2c:	e59f0150 	ldr	r0, [pc, #336]	; c84 <.text+0xc84>
 b30:	ebffff05 	bl	74c <uart0_printf>
     long_to_hex_string((unsigned long ) NUM_BYTES, str, 8);
 b34:	e1a01005 	mov	r1, r5
 b38:	e3a02008 	mov	r2, #8	; 0x8
 b3c:	e3a00b01 	mov	r0, #1024	; 0x400
 b40:	ebffffc6 	bl	a60 <long_to_hex_string>
     uart0_printf(str);uart0_printf("\r\n");
 b44:	e1a00005 	mov	r0, r5
 b48:	ebfffeff 	bl	74c <uart0_printf>
 b4c:	e59f012c 	ldr	r0, [pc, #300]	; c80 <.text+0xc80>
 b50:	ebfffefd 	bl	74c <uart0_printf>
 b54:	e3a06001 	mov	r6, #1	; 0x1
  for (i=1; i<=CYCLES; i++) {	
    result = memTestDataBus(BASE_ADDRESS);
 b58:	e3a00402 	mov	r0, #33554432	; 0x2000000
 b5c:	ebffff25 	bl	7f8 <memTestDataBus>
    if ( result != 0)
 b60:	e3500000 	cmp	r0, #0	; 0x0
 b64:	1a00003e 	bne	c64 <main+0x194>
    {
        uart0_printf("memTestDataBus FAILED\r\n");
		return (-1);
    }
    else
    {
        uart0_printf("memTestDataBus Passed\r\n");
 b68:	e59f0118 	ldr	r0, [pc, #280]	; c88 <.text+0xc88>
 b6c:	ebfffef6 	bl	74c <uart0_printf>

    }
	result_ptr = memTestAddressBus(BASE_ADDRESS, NUM_BYTES);
 b70:	e3a00402 	mov	r0, #33554432	; 0x2000000
 b74:	e3a01b01 	mov	r1, #1024	; 0x400
 b78:	ebffff27 	bl	81c <memTestAddressBus>
    if ( result_ptr != NULL)
 b7c:	e2504000 	subs	r4, r0, #0	; 0x0
 b80:	0a000034 	beq	c58 <main+0x188>
    {
       uart0_printf("memTestAddressBus FAILED ");
 b84:	e59f0100 	ldr	r0, [pc, #256]	; c8c <.text+0xc8c>
 b88:	ebfffeef 	bl	74c <uart0_printf>
	   long_to_hex_string((unsigned long ) result_ptr, str, 8);
 b8c:	e1a00004 	mov	r0, r4
 b90:	e1a01005 	mov	r1, r5
 b94:	e3a02008 	mov	r2, #8	; 0x8
 b98:	ebffffb0 	bl	a60 <long_to_hex_string>
		uart0_printf(str);uart0_printf("\r\n");
 b9c:	e1a00005 	mov	r0, r5
 ba0:	ebfffee9 	bl	74c <uart0_printf>
 ba4:	e59f00d4 	ldr	r0, [pc, #212]	; c80 <.text+0xc80>
 ba8:	ebfffee7 	bl	74c <uart0_printf>
		//return (-1);
    }
    else
    {
        uart0_printf("memTestAddressBus Passed\r\n");
    }

    result_ptr = memTestDevice1(BASE_ADDRESS, NUM_BYTES);
 bac:	e3a00402 	mov	r0, #33554432	; 0x2000000
 bb0:	e3a01b01 	mov	r1, #1024	; 0x400
 bb4:	ebffff74 	bl	98c <memTestDevice1>
    if ( result_ptr != NULL)
 bb8:	e2504000 	subs	r4, r0, #0	; 0x0
 bbc:	0a000022 	beq	c4c <main+0x17c>
    {
        uart0_printf("memTestDevice1 FAILED ");
 bc0:	e59f00c8 	ldr	r0, [pc, #200]	; c90 <.text+0xc90>
 bc4:	ebfffee0 	bl	74c <uart0_printf>
		long_to_hex_string((unsigned long ) result_ptr, str, 8);
 bc8:	e1a00004 	mov	r0, r4
 bcc:	e1a01005 	mov	r1, r5
 bd0:	e3a02008 	mov	r2, #8	; 0x8
 bd4:	ebffffa1 	bl	a60 <long_to_hex_string>
		uart0_printf(str);uart0_printf("\r\n");
 bd8:	e1a00005 	mov	r0, r5
 bdc:	ebfffeda 	bl	74c <uart0_printf>
 be0:	e59f0098 	ldr	r0, [pc, #152]	; c80 <.text+0xc80>
 be4:	ebfffed8 	bl	74c <uart0_printf>
		//return (-1);
    }
    else
    {
        uart0_printf("memTestDevice1 Passed\r\n");
		//return (0);
    }

	
    result_ptr = memTestDevice2(BASE_ADDRESS, NUM_BYTES);
 be8:	e3a00402 	mov	r0, #33554432	; 0x2000000
 bec:	e3a01b01 	mov	r1, #1024	; 0x400
 bf0:	ebffff7e 	bl	9f0 <memTestDevice2>
    if ( result_ptr != NULL)
 bf4:	e2504000 	subs	r4, r0, #0	; 0x0
 bf8:	0a000010 	beq	c40 <main+0x170>
    {
        uart0_printf("memTestDevice2 FAILED ");
 bfc:	e59f0090 	ldr	r0, [pc, #144]	; c94 <.text+0xc94>
 c00:	ebfffed1 	bl	74c <uart0_printf>
		long_to_hex_string((unsigned long ) result_ptr, str, 8);
 c04:	e1a00004 	mov	r0, r4
 c08:	e1a01005 	mov	r1, r5
 c0c:	e3a02008 	mov	r2, #8	; 0x8
 c10:	ebffff92 	bl	a60 <long_to_hex_string>
		uart0_printf(str);uart0_printf("\r\n");
 c14:	e1a00005 	mov	r0, r5
 c18:	ebfffecb 	bl	74c <uart0_printf>
 c1c:	e59f005c 	ldr	r0, [pc, #92]	; c80 <.text+0xc80>
 c20:	ebfffec9 	bl	74c <uart0_printf>
 c24:	e2866001 	add	r6, r6, #1	; 0x1
 c28:	e3560006 	cmp	r6, #6	; 0x6
 c2c:	1affffc9 	bne	b58 <main+0x88>
		//return (-1);
    }
    else
    {
        uart0_printf("memTestDevice2 Passed\r\n");
		//return (0);
    }
   } //for
	asm volatile ("mov pc, #00010000");
 c30:	e3a0fa01 	mov	pc, #4096	; 0x1000
 c34:	e3a00000 	mov	r0, #0	; 0x0
}   /* memTest() */
 c38:	e28dd00c 	add	sp, sp, #12	; 0xc
 c3c:	e8bd8070 	ldmia	sp!, {r4, r5, r6, pc}
 c40:	e59f0050 	ldr	r0, [pc, #80]	; c98 <.text+0xc98>
 c44:	ebfffec0 	bl	74c <uart0_printf>
 c48:	eafffff5 	b	c24 <main+0x154>
 c4c:	e59f0048 	ldr	r0, [pc, #72]	; c9c <.text+0xc9c>
 c50:	ebfffebd 	bl	74c <uart0_printf>
 c54:	eaffffe3 	b	be8 <main+0x118>
 c58:	e59f0040 	ldr	r0, [pc, #64]	; ca0 <.text+0xca0>
 c5c:	ebfffeba 	bl	74c <uart0_printf>
 c60:	eaffffd1 	b	bac <main+0xdc>
 c64:	e59f0038 	ldr	r0, [pc, #56]	; ca4 <.text+0xca4>
 c68:	ebfffeb7 	bl	74c <uart0_printf>
 c6c:	e3e00000 	mvn	r0, #0	; 0x0
 c70:	eafffff0 	b	c38 <main+0x168>
 c74:	00000cc8 	andeq	r0, r0, r8, asr #25
 c78:	00000cd4 	ldreqd	r0, [r0], -r4
 c7c:	00000cf0 	streqd	r0, [r0], -r0
 c80:	00000d78 	andeq	r0, r0, r8, ror sp
 c84:	00000d00 	andeq	r0, r0, r0, lsl #26
 c88:	00000d2c 	andeq	r0, r0, ip, lsr #26
 c8c:	00000d44 	andeq	r0, r0, r4, asr #26
 c90:	00000d7c 	andeq	r0, r0, ip, ror sp
 c94:	00000dac 	andeq	r0, r0, ip, lsr #27
 c98:	00000dc4 	andeq	r0, r0, r4, asr #27
 c9c:	00000d94 	muleq	r0, r4, sp
 ca0:	00000d60 	andeq	r0, r0, r0, ror #26
 ca4:	00000d14 	andeq	r0, r0, r4, lsl sp

00000ca8 <io_enable_xint>:
//		case 14:         asm volatile ("mcr p15,0,%0,c14,c14,0" : /* no outputs */ : "r" (_cp_val)); break;
//		case 15:         asm volatile ("mcr p15,0,%0,c15,c15,0" : /* no outputs */ : "r" (_cp_val)); break;
		default:         break;
	}
}
// ******************************************************************************
// read CMSR value
   static inline unsigned long get_cmsr(void)
// ******************************************************************************
{
	unsigned long _cmsr;
	asm volatile (" mrs %0, cpsr" : "=r" (_cmsr) : /* no inputs */  );
 ca8:	e10f3000 	mrs	r3, CPSR
	return _cmsr;
}

// ******************************************************************************
// write CMSR value
   static inline void set_cmsr(unsigned long _cmsr)
// ******************************************************************************
{
	asm volatile (" msr cpsr, %0" : /* no outputs */ : "r" (_cmsr)  );
 cac:	e3c330c0 	bic	r3, r3, #192	; 0xc0
 cb0:	e129f003 	msr	CPSR_fc, r3
}

// ******************************************************************************
// Enable all external INTs
   void io_enable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr & ~(1<<CMSR_FIQ) &~(1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
 cb4:	e12fff1e 	bx	lr

00000cb8 <io_disable_xint>:
 cb8:	e10f3000 	mrs	r3, CPSR
 cbc:	e38330c0 	orr	r3, r3, #192	; 0xc0
 cc0:	e129f003 	msr	CPSR_fc, r3

// ******************************************************************************
// Disable all global IBTs
   void io_disable_xint(void)
// ******************************************************************************
{
	unsigned long _cmsr = get_cmsr();
	_cmsr = _cmsr | (1<<CMSR_FIQ) | (1<<CMSR_IRQ);
	set_cmsr(_cmsr);
}
 cc4:	e12fff1e 	bx	lr
	...
 cd4:	53746172 	cmnpl	r4, #-2147483620	; 0x8000001c
 cd8:	74696e67 	strvcbt	r6, [r9], #-3687
 cdc:	204d454d 	subcs	r4, sp, sp, asr #10
 ce0:	54455354 	strplb	r5, [r5], #-852
 ce4:	20746573 	rsbcss	r6, r4, r3, ror r5
 ce8:	74730d0a 	ldrvcbt	r0, [r3], #-3338
 cec:	00000000 	andeq	r0, r0, r0
 cf0:	42415345 	submi	r5, r1, #335544321	; 0x14000001
 cf4:	20414444 	subcs	r4, r1, r4, asr #8
 cf8:	52455353 	subpl	r5, r5, #1275068417	; 0x4c000001
 cfc:	3a202000 	bcc	808d04 <_end+0x803f04>
 d00:	4e756d62 	cdpmi	13, 7, cr6, cr5, cr2, {3}
 d04:	6572206f 	ldrvsb	r2, [r2, #-111]!
 d08:	66204279 	undefined
 d0c:	7465733a 	strvcbt	r7, [r5], #-826
 d10:	20200000 	eorcs	r0, r0, r0
 d14:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 d18:	65737444 	ldrvsb	r7, [r3, #-1092]!
 d1c:	61746142 	cmnvs	r4, r2, asr #2
 d20:	75732046 	ldrvcb	r2, [r3, #-70]!
 d24:	41494c45 	cmpmi	r9, r5, asr #24
 d28:	440d0a00 	strmi	r0, [sp], #-2560
 d2c:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 d30:	65737444 	ldrvsb	r7, [r3, #-1092]!
 d34:	61746142 	cmnvs	r4, r2, asr #2
 d38:	75732050 	ldrvcb	r2, [r3, #-80]!
 d3c:	61737365 	cmnvs	r3, r5, ror #6
 d40:	640d0a00 	strvs	r0, [sp], #-2560
 d44:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 d48:	65737441 	ldrvsb	r7, [r3, #-1089]!
 d4c:	64647265 	strvsbt	r7, [r4], #-613
 d50:	73734275 	cmnvc	r3, #1342177287	; 0x50000007
 d54:	73204641 	teqvc	r0, #68157440	; 0x4100000
 d58:	494c4544 	stmmidb	ip, {r2, r6, r8, sl, lr}^
 d5c:	20000000 	andcs	r0, r0, r0
 d60:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 d64:	65737441 	ldrvsb	r7, [r3, #-1089]!
 d68:	64647265 	strvsbt	r7, [r4], #-613
 d6c:	73734275 	cmnvc	r3, #1342177287	; 0x50000007
 d70:	73205061 	teqvc	r0, #97	; 0x61
 d74:	73736564 	cmnvc	r3, #419430400	; 0x19000000
 d78:	0d0a0000 	stceq	0, cr0, [sl]
 d7c:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 d80:	65737444 	ldrvsb	r7, [r3, #-1092]!
 d84:	65766963 	ldrvsb	r6, [r6, #-2403]!
 d88:	65312046 	ldrvs	r2, [r1, #-70]!
 d8c:	41494c45 	cmpmi	r9, r5, asr #24
 d90:	44200000 	strmit	r0, [r0]
 d94:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 d98:	65737444 	ldrvsb	r7, [r3, #-1092]!
 d9c:	65766963 	ldrvsb	r6, [r6, #-2403]!
 da0:	65312050 	ldrvs	r2, [r1, #-80]!
 da4:	61737365 	cmnvs	r3, r5, ror #6
 da8:	640d0a00 	strvs	r0, [sp], #-2560
 dac:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 db0:	65737444 	ldrvsb	r7, [r3, #-1092]!
 db4:	65766963 	ldrvsb	r6, [r6, #-2403]!
 db8:	65322046 	ldrvs	r2, [r2, #-70]!
 dbc:	41494c45 	cmpmi	r9, r5, asr #24
 dc0:	44200000 	strmit	r0, [r0]
 dc4:	6d656d54 	stcvsl	13, cr6, [r5, #-336]!
 dc8:	65737444 	ldrvsb	r7, [r3, #-1092]!
 dcc:	65766963 	ldrvsb	r6, [r6, #-2403]!
 dd0:	65322050 	ldrvs	r2, [r2, #-80]!
 dd4:	61737365 	cmnvs	r3, r5, ror #6
 dd8:	640d0a00 	strvs	r0, [sp], #-2560
